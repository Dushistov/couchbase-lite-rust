pub const kInvalidID : u32 = 0 ;
pub const kCFCoreFoundationVersionNumber10_0 : f64 = 196.4 ;
pub const kCFCoreFoundationVersionNumber10_0_3 : f64 = 196.5 ;
pub const kCFCoreFoundationVersionNumber10_1 : f64 = 226.0 ;
pub const kCFCoreFoundationVersionNumber10_1_1 : f64 = 226.0 ;
pub const kCFCoreFoundationVersionNumber10_1_2 : f64 = 227.2 ;
pub const kCFCoreFoundationVersionNumber10_1_3 : f64 = 227.2 ;
pub const kCFCoreFoundationVersionNumber10_1_4 : f64 = 227.3 ;
pub const kCFCoreFoundationVersionNumber10_2 : f64 = 263.0 ;
pub const kCFCoreFoundationVersionNumber10_2_1 : f64 = 263.1 ;
pub const kCFCoreFoundationVersionNumber10_2_2 : f64 = 263.1 ;
pub const kCFCoreFoundationVersionNumber10_2_3 : f64 = 263.3 ;
pub const kCFCoreFoundationVersionNumber10_2_4 : f64 = 263.3 ;
pub const kCFCoreFoundationVersionNumber10_2_5 : f64 = 263.5 ;
pub const kCFCoreFoundationVersionNumber10_2_6 : f64 = 263.5 ;
pub const kCFCoreFoundationVersionNumber10_2_7 : f64 = 263.5 ;
pub const kCFCoreFoundationVersionNumber10_2_8 : f64 = 263.5 ;
pub const kCFCoreFoundationVersionNumber10_3 : f64 = 299.0 ;
pub const kCFCoreFoundationVersionNumber10_3_1 : f64 = 299.0 ;
pub const kCFCoreFoundationVersionNumber10_3_2 : f64 = 299.0 ;
pub const kCFCoreFoundationVersionNumber10_3_3 : f64 = 299.3 ;
pub const kCFCoreFoundationVersionNumber10_3_4 : f64 = 299.31 ;
pub const kCFCoreFoundationVersionNumber10_3_5 : f64 = 299.31 ;
pub const kCFCoreFoundationVersionNumber10_3_6 : f64 = 299.32 ;
pub const kCFCoreFoundationVersionNumber10_3_7 : f64 = 299.33 ;
pub const kCFCoreFoundationVersionNumber10_3_8 : f64 = 299.33 ;
pub const kCFCoreFoundationVersionNumber10_3_9 : f64 = 299.35 ;
pub const kCFCoreFoundationVersionNumber10_4 : f64 = 368.0 ;
pub const kCFCoreFoundationVersionNumber10_4_1 : f64 = 368.1 ;
pub const kCFCoreFoundationVersionNumber10_4_2 : f64 = 368.11 ;
pub const kCFCoreFoundationVersionNumber10_4_3 : f64 = 368.18 ;
pub const kCFCoreFoundationVersionNumber10_4_4_Intel : f64 = 368.26 ;
pub const kCFCoreFoundationVersionNumber10_4_4_PowerPC : f64 = 368.25 ;
pub const kCFCoreFoundationVersionNumber10_4_5_Intel : f64 = 368.26 ;
pub const kCFCoreFoundationVersionNumber10_4_5_PowerPC : f64 = 368.25 ;
pub const kCFCoreFoundationVersionNumber10_4_6_Intel : f64 = 368.26 ;
pub const kCFCoreFoundationVersionNumber10_4_6_PowerPC : f64 = 368.25 ;
pub const kCFCoreFoundationVersionNumber10_4_7 : f64 = 368.27 ;
pub const kCFCoreFoundationVersionNumber10_4_8 : f64 = 368.27 ;
pub const kCFCoreFoundationVersionNumber10_4_9 : f64 = 368.28 ;
pub const kCFCoreFoundationVersionNumber10_4_10 : f64 = 368.28 ;
pub const kCFCoreFoundationVersionNumber10_4_11 : f64 = 368.31 ;
pub const kCFCoreFoundationVersionNumber10_5 : f64 = 476.0 ;
pub const kCFCoreFoundationVersionNumber10_5_1 : f64 = 476.0 ;
pub const kCFCoreFoundationVersionNumber10_5_2 : f64 = 476.1 ;
pub const kCFCoreFoundationVersionNumber10_5_3 : f64 = 476.13 ;
pub const kCFCoreFoundationVersionNumber10_5_4 : f64 = 476.14 ;
pub const kCFCoreFoundationVersionNumber10_5_5 : f64 = 476.15 ;
pub const kCFCoreFoundationVersionNumber10_5_6 : f64 = 476.17 ;
pub const kCFCoreFoundationVersionNumber10_5_7 : f64 = 476.18 ;
pub const kCFCoreFoundationVersionNumber10_5_8 : f64 = 476.19 ;
pub const kCFCoreFoundationVersionNumber10_6 : f64 = 550.0 ;
pub const kCFCoreFoundationVersionNumber10_6_1 : f64 = 550.0 ;
pub const kCFCoreFoundationVersionNumber10_6_2 : f64 = 550.13 ;
pub const kCFCoreFoundationVersionNumber10_6_3 : f64 = 550.19 ;
pub const kCFCoreFoundationVersionNumber10_6_4 : f64 = 550.29 ;
pub const kCFCoreFoundationVersionNumber10_6_5 : f64 = 550.42 ;
pub const kCFCoreFoundationVersionNumber10_6_6 : f64 = 550.42 ;
pub const kCFCoreFoundationVersionNumber10_6_7 : f64 = 550.42 ;
pub const kCFCoreFoundationVersionNumber10_6_8 : f64 = 550.43 ;
pub const kCFCoreFoundationVersionNumber10_7 : f64 = 635.0 ;
pub const kCFCoreFoundationVersionNumber10_7_1 : f64 = 635.0 ;
pub const kCFCoreFoundationVersionNumber10_7_2 : f64 = 635.15 ;
pub const kCFCoreFoundationVersionNumber10_7_3 : f64 = 635.19 ;
pub const kCFCoreFoundationVersionNumber10_7_4 : f64 = 635.21 ;
pub const kCFCoreFoundationVersionNumber10_7_5 : f64 = 635.21 ;
pub const kCFCoreFoundationVersionNumber10_8 : f64 = 744.0 ;
pub const kCFCoreFoundationVersionNumber10_8_1 : f64 = 744.0 ;
pub const kCFCoreFoundationVersionNumber10_8_2 : f64 = 744.12 ;
pub const kCFCoreFoundationVersionNumber10_8_3 : f64 = 744.18 ;
pub const kCFCoreFoundationVersionNumber10_8_4 : f64 = 744.19 ;
pub const kCFCoreFoundationVersionNumber10_9 : f64 = 855.11 ;
pub const kCFCoreFoundationVersionNumber10_9_1 : f64 = 855.11 ;
pub const kCFCoreFoundationVersionNumber10_9_2 : f64 = 855.14 ;
pub const kCFCoreFoundationVersionNumber10_10 : f64 = 1151.16 ;
pub const kCFCoreFoundationVersionNumber10_10_1 : f64 = 1151.16 ;
pub const kCFCoreFoundationVersionNumber10_10_2 : u32 = 1152 ;
pub const kCFCoreFoundationVersionNumber10_10_3 : f64 = 1153.18 ;
pub const kCFCoreFoundationVersionNumber10_10_4 : f64 = 1153.18 ;
pub const kCFCoreFoundationVersionNumber10_10_5 : f64 = 1153.18 ;
pub const kCFCoreFoundationVersionNumber10_10_Max : u32 = 1199 ;
pub const kCFCoreFoundationVersionNumber10_11 : u32 = 1253 ;
pub const kCFCoreFoundationVersionNumber10_11_1 : f64 = 1255.1 ;
pub const kCFCoreFoundationVersionNumber10_11_2 : f64 = 1256.14 ;
pub const kCFCoreFoundationVersionNumber10_11_3 : f64 = 1256.14 ;
pub const kCFCoreFoundationVersionNumber10_11_4 : f64 = 1258.1 ;
pub const kCFCoreFoundationVersionNumber10_11_Max : u32 = 1299 ;
pub const kC4EnvironmentTimezoneKey : & [u8 ; 3] = b"tz\0" ;
pub const kC4EnvironmentSupportedLocales : & [u8 ; 18] = b"supported_locales\0" ;
pub const kC4GeneratedIDLength : u32 = 23 ;
pub const kC4ObjectTypeProperty : & [u8 ; 6] = b"@type\0" ;
pub const kC4ObjectType_Blob : & [u8 ; 5] = b"blob\0" ;
pub const kC4BlobDigestProperty : & [u8 ; 7] = b"digest\0" ;
pub const kC4BlobDataProperty : & [u8 ; 5] = b"data\0" ;
pub const kC4LegacyAttachmentsProperty : & [u8 ; 13] = b"_attachments\0" ;
pub const kC4ObjectType_Encryptable : & [u8 ; 12] = b"encryptable\0" ;
pub const kC4EncryptableValueProperty : & [u8 ; 6] = b"value\0" ;
pub const kC4ReplicatorOptionDocIDs : & [u8 ; 7] = b"docIDs\0" ;
pub const kC4ReplicatorOptionChannels : & [u8 ; 9] = b"channels\0" ;
pub const kC4ReplicatorOptionFilter : & [u8 ; 7] = b"filter\0" ;
pub const kC4ReplicatorOptionFilterParams : & [u8 ; 13] = b"filterParams\0" ;
pub const kC4ReplicatorOptionSkipDeleted : & [u8 ; 12] = b"skipDeleted\0" ;
pub const kC4ReplicatorOptionNoIncomingConflicts : & [u8 ; 20] = b"noIncomingConflicts\0" ;
pub const kC4ReplicatorCheckpointInterval : & [u8 ; 19] = b"checkpointInterval\0" ;
pub const kC4ReplicatorOptionRemoteDBUniqueID : & [u8 ; 17] = b"remoteDBUniqueID\0" ;
pub const kC4ReplicatorOptionDisableDeltas : & [u8 ; 9] = b"noDeltas\0" ;
pub const kC4ReplicatorOptionDisablePropertyDecryption : & [u8 ; 13] = b"noDecryption\0" ;
pub const kC4ReplicatorOptionMaxRetries : & [u8 ; 11] = b"maxRetries\0" ;
pub const kC4ReplicatorOptionMaxRetryInterval : & [u8 ; 17] = b"maxRetryInterval\0" ;
pub const kC4ReplicatorOptionAutoPurge : & [u8 ; 10] = b"autoPurge\0" ;
pub const kC4ReplicatorOptionAcceptParentDomainCookies : & [u8 ; 26] = b"acceptParentDomainCookies\0" ;
pub const kC4ReplicatorOptionRootCerts : & [u8 ; 10] = b"rootCerts\0" ;
pub const kC4ReplicatorOptionPinnedServerCert : & [u8 ; 11] = b"pinnedCert\0" ;
pub const kC4ReplicatorOptionOnlySelfSignedServerCert : & [u8 ; 21] = b"onlySelfSignedServer\0" ;
pub const kC4ReplicatorOptionExtraHeaders : & [u8 ; 8] = b"headers\0" ;
pub const kC4ReplicatorOptionCookies : & [u8 ; 8] = b"cookies\0" ;
pub const kC4ReplicatorOptionAuthentication : & [u8 ; 5] = b"auth\0" ;
pub const kC4ReplicatorOptionProxyServer : & [u8 ; 6] = b"proxy\0" ;
pub const kC4ReplicatorHeartbeatInterval : & [u8 ; 10] = b"heartbeat\0" ;
pub const kC4SocketOptionWSProtocols : & [u8 ; 13] = b"WS-Protocols\0" ;
pub const kC4SocketOptionNetworkInterface : & [u8 ; 17] = b"networkInterface\0" ;
pub const kC4ReplicatorCompressionLevel : & [u8 ; 21] = b"BLIPCompressionLevel\0" ;
pub const kC4ReplicatorAuthType : & [u8 ; 5] = b"type\0" ;
pub const kC4ReplicatorAuthUserName : & [u8 ; 9] = b"username\0" ;
pub const kC4ReplicatorAuthPassword : & [u8 ; 9] = b"password\0" ;
pub const kC4ReplicatorAuthEnableChallengeAuth : & [u8 ; 14] = b"challengeAuth\0" ;
pub const kC4ReplicatorAuthClientCert : & [u8 ; 11] = b"clientCert\0" ;
pub const kC4ReplicatorAuthClientCertKey : & [u8 ; 14] = b"clientCertKey\0" ;
pub const kC4ReplicatorAuthToken : & [u8 ; 6] = b"token\0" ;
pub const kC4AuthTypeBasic : & [u8 ; 6] = b"Basic\0" ;
pub const kC4AuthTypeSession : & [u8 ; 8] = b"Session\0" ;
pub const kC4AuthTypeOpenIDConnect : & [u8 ; 15] = b"OpenID Connect\0" ;
pub const kC4AuthTypeFacebook : & [u8 ; 9] = b"Facebook\0" ;
pub const kC4AuthTypeClientCert : & [u8 ; 12] = b"Client Cert\0" ;
pub const kC4ReplicatorProxyType : & [u8 ; 5] = b"type\0" ;
pub const kC4ReplicatorProxyHost : & [u8 ; 5] = b"host\0" ;
pub const kC4ReplicatorProxyPort : & [u8 ; 5] = b"port\0" ;
pub const kC4ReplicatorProxyAuth : & [u8 ; 5] = b"auth\0" ;
pub const kC4ProxyTypeNone : & [u8 ; 5] = b"none\0" ;
pub const kC4ProxyTypeHTTP : & [u8 ; 5] = b"HTTP\0" ;
pub const kC4ProxyTypeHTTPS : & [u8 ; 6] = b"HTTPS\0" ;
pub const kC4ProxyTypeSOCKS : & [u8 ; 6] = b"SOCKS\0" ;
pub type __int64_t = :: std :: os :: raw :: c_longlong ;
pub type __darwin_va_list = __builtin_va_list ;
pub type __darwin_off_t = __int64_t ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct FLSlice { pub buf : * const :: std :: os :: raw :: c_void , pub size : usize , }
# [repr (C)] # [derive (Debug)] pub struct FLSliceResult { pub buf : * const :: std :: os :: raw :: c_void , pub size : usize , }
pub type FLHeapSlice = FLSlice ;
pub type FLString = FLSlice ;
pub type FLStringResult = FLSliceResult ;
extern "C" { pub fn FLSlice_Equal (a : FLSlice , b : FLSlice) -> bool ; }
extern "C" { pub fn FLSlice_Compare (arg1 : FLSlice , arg2 : FLSlice) -> :: std :: os :: raw :: c_int ; }
extern "C" { pub fn FLSlice_Hash (s : FLSlice) -> u32 ; }
extern "C" { pub fn FLSlice_ToCString (s : FLSlice , buffer : * mut :: std :: os :: raw :: c_char , capacity : usize ,) -> bool ; }
extern "C" { pub fn FLSliceResult_New (arg1 : usize) -> FLSliceResult ; }
extern "C" { pub fn FLSlice_Copy (arg1 : FLSlice) -> FLSliceResult ; }
extern "C" { pub fn _FLBuf_Retain (arg1 : * const :: std :: os :: raw :: c_void) ; }
extern "C" { pub fn _FLBuf_Release (arg1 : * const :: std :: os :: raw :: c_void) ; }
extern "C" { pub fn FL_WipeMemory (dst : * mut :: std :: os :: raw :: c_void , size : usize) ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLValue { _unused : [u8 ; 0] , }
pub type FLValue = * const _FLValue ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLArray { _unused : [u8 ; 0] , }
pub type FLArray = * const _FLArray ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLDict { _unused : [u8 ; 0] , }
pub type FLDict = * const _FLDict ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLSlot { _unused : [u8 ; 0] , }
pub type FLSlot = * mut _FLSlot ;
pub type FLMutableArray = * mut _FLArray ;
pub type FLMutableDict = * mut _FLDict ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLEncoder { _unused : [u8 ; 0] , }
pub type FLEncoder = * mut _FLEncoder ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLDoc { _unused : [u8 ; 0] , }
pub type FLDoc = * mut _FLDoc ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLSharedKeys { _unused : [u8 ; 0] , }
pub type FLSharedKeys = * mut _FLSharedKeys ;
impl FLError { pub const kFLNoError : FLError = FLError (0) ; }
impl FLError { pub const kFLMemoryError : FLError = FLError (1) ; }
impl FLError { pub const kFLOutOfRange : FLError = FLError (2) ; }
impl FLError { pub const kFLInvalidData : FLError = FLError (3) ; }
impl FLError { pub const kFLEncodeError : FLError = FLError (4) ; }
impl FLError { pub const kFLJSONError : FLError = FLError (5) ; }
impl FLError { pub const kFLUnknownValue : FLError = FLError (6) ; }
impl FLError { pub const kFLInternalError : FLError = FLError (7) ; }
impl FLError { pub const kFLNotFound : FLError = FLError (8) ; }
impl FLError { pub const kFLSharedKeysStateError : FLError = FLError (9) ; }
impl FLError { pub const kFLPOSIXError : FLError = FLError (10) ; }
impl FLError { pub const kFLUnsupported : FLError = FLError (11) ; }
# [repr (transparent)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub struct FLError (pub :: std :: os :: raw :: c_uint) ;
# [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum FLTrust { kFLUntrusted = 0 , kFLTrusted = 1 , }
pub type FLTimestamp = i64 ;
extern "C" { pub fn FLTimestamp_Now () -> FLTimestamp ; }
extern "C" { pub fn FLTimestamp_ToString (timestamp : FLTimestamp , asUTC : bool) -> FLStringResult ; }
extern "C" { pub fn FLTimestamp_FromString (str_ : FLString) -> FLTimestamp ; }
extern "C" { pub static kFLEmptyArray : FLArray ; }
extern "C" { pub fn FLArray_Count (arg1 : FLArray) -> u32 ; }
extern "C" { pub fn FLArray_IsEmpty (arg1 : FLArray) -> bool ; }
extern "C" { pub fn FLArray_AsMutable (arg1 : FLArray) -> FLMutableArray ; }
extern "C" { pub fn FLArray_Get (arg1 : FLArray , index : u32) -> FLValue ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct FLArrayIterator { pub _private1 : * mut :: std :: os :: raw :: c_void , pub _private2 : u32 , pub _private3 : bool , pub _private4 : * mut :: std :: os :: raw :: c_void , }
extern "C" { pub fn FLArrayIterator_Begin (arg1 : FLArray , arg2 : * mut FLArrayIterator) ; }
extern "C" { pub fn FLArrayIterator_GetValue (arg1 : * const FLArrayIterator) -> FLValue ; }
extern "C" { pub fn FLArrayIterator_GetValueAt (arg1 : * const FLArrayIterator , offset : u32) -> FLValue ; }
extern "C" { pub fn FLArrayIterator_GetCount (arg1 : * const FLArrayIterator) -> u32 ; }
extern "C" { pub fn FLArrayIterator_Next (arg1 : * mut FLArrayIterator) -> bool ; }
extern "C" { pub static kFLEmptyDict : FLDict ; }
extern "C" { pub fn FLDict_Count (arg1 : FLDict) -> u32 ; }
extern "C" { pub fn FLDict_IsEmpty (arg1 : FLDict) -> bool ; }
extern "C" { pub fn FLDict_AsMutable (arg1 : FLDict) -> FLMutableDict ; }
extern "C" { pub fn FLDict_Get (arg1 : FLDict , keyString : FLSlice) -> FLValue ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct FLDictIterator { pub _private1 : * mut :: std :: os :: raw :: c_void , pub _private2 : u32 , pub _private3 : bool , pub _private4 : * mut :: std :: os :: raw :: c_void , pub _private5 : * mut :: std :: os :: raw :: c_void , pub _private6 : * mut :: std :: os :: raw :: c_void , pub _private7 : * mut :: std :: os :: raw :: c_void , pub _private8 : :: std :: os :: raw :: c_int , }
extern "C" { pub fn FLDictIterator_Begin (arg1 : FLDict , arg2 : * mut FLDictIterator) ; }
extern "C" { pub fn FLDictIterator_GetKey (arg1 : * const FLDictIterator) -> FLValue ; }
extern "C" { pub fn FLDictIterator_GetKeyString (arg1 : * const FLDictIterator) -> FLString ; }
extern "C" { pub fn FLDictIterator_GetValue (arg1 : * const FLDictIterator) -> FLValue ; }
extern "C" { pub fn FLDictIterator_GetCount (arg1 : * const FLDictIterator) -> u32 ; }
extern "C" { pub fn FLDictIterator_Next (arg1 : * mut FLDictIterator) -> bool ; }
extern "C" { pub fn FLDictIterator_End (arg1 : * mut FLDictIterator) ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct FLDictKey { pub _private1 : FLSlice , pub _private2 : * mut :: std :: os :: raw :: c_void , pub _private3 : u32 , pub private4 : u32 , pub private5 : bool , }
extern "C" { pub fn FLDictKey_Init (string : FLSlice) -> FLDictKey ; }
extern "C" { pub fn FLDictKey_GetString (arg1 : * const FLDictKey) -> FLString ; }
extern "C" { pub fn FLDict_GetWithKey (arg1 : FLDict , arg2 : * mut FLDictKey) -> FLValue ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLDeepIterator { _unused : [u8 ; 0] , }
pub type FLDeepIterator = * mut _FLDeepIterator ;
extern "C" { pub fn FLDeepIterator_New (arg1 : FLValue) -> FLDeepIterator ; }
extern "C" { pub fn FLDeepIterator_Free (arg1 : FLDeepIterator) ; }
extern "C" { pub fn FLDeepIterator_GetValue (arg1 : FLDeepIterator) -> FLValue ; }
extern "C" { pub fn FLDeepIterator_GetParent (arg1 : FLDeepIterator) -> FLValue ; }
extern "C" { pub fn FLDeepIterator_GetKey (arg1 : FLDeepIterator) -> FLSlice ; }
extern "C" { pub fn FLDeepIterator_GetIndex (arg1 : FLDeepIterator) -> u32 ; }
extern "C" { pub fn FLDeepIterator_GetDepth (arg1 : FLDeepIterator) -> usize ; }
extern "C" { pub fn FLDeepIterator_SkipChildren (arg1 : FLDeepIterator) ; }
extern "C" { pub fn FLDeepIterator_Next (arg1 : FLDeepIterator) -> bool ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct FLPathComponent { pub key : FLSlice , pub index : u32 , }
extern "C" { pub fn FLDeepIterator_GetPath (arg1 : FLDeepIterator , outPath : * mut * mut FLPathComponent , outDepth : * mut usize ,) ; }
extern "C" { pub fn FLDeepIterator_GetPathString (arg1 : FLDeepIterator) -> FLSliceResult ; }
extern "C" { pub fn FLDeepIterator_GetJSONPointer (arg1 : FLDeepIterator) -> FLSliceResult ; }
extern "C" { pub fn FLDoc_FromResultData (data : FLSliceResult , arg1 : FLTrust , arg2 : FLSharedKeys , externData : FLSlice ,) -> FLDoc ; }
extern "C" { pub fn FLDoc_Release (arg1 : FLDoc) ; }
extern "C" { pub fn FLDoc_Retain (arg1 : FLDoc) -> FLDoc ; }
extern "C" { pub fn FLDoc_GetData (arg1 : FLDoc) -> FLSlice ; }
extern "C" { pub fn FLDoc_GetAllocedData (arg1 : FLDoc) -> FLSliceResult ; }
extern "C" { pub fn FLDoc_GetRoot (arg1 : FLDoc) -> FLValue ; }
extern "C" { pub fn FLDoc_GetSharedKeys (arg1 : FLDoc) -> FLSharedKeys ; }
extern "C" { pub fn FLValue_FindDoc (arg1 : FLValue) -> FLDoc ; }
extern "C" { pub fn FLDoc_SetAssociated (doc : FLDoc , pointer : * mut :: std :: os :: raw :: c_void , type_ : * const :: std :: os :: raw :: c_char ,) -> bool ; }
extern "C" { pub fn FLDoc_GetAssociated (doc : FLDoc , type_ : * const :: std :: os :: raw :: c_char ,) -> * mut :: std :: os :: raw :: c_void ; }
pub type va_list = __darwin_va_list ;
pub type fpos_t = __darwin_off_t ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sbuf { pub _base : * mut :: std :: os :: raw :: c_uchar , pub _size : :: std :: os :: raw :: c_int , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sFILEX { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __sFILE { pub _p : * mut :: std :: os :: raw :: c_uchar , pub _r : :: std :: os :: raw :: c_int , pub _w : :: std :: os :: raw :: c_int , pub _flags : :: std :: os :: raw :: c_short , pub _file : :: std :: os :: raw :: c_short , pub _bf : __sbuf , pub _lbfsize : :: std :: os :: raw :: c_int , pub _cookie : * mut :: std :: os :: raw :: c_void , pub _close : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) -> :: std :: os :: raw :: c_int , > , pub _read : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * mut :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int , > , pub _seek : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : fpos_t , arg3 : :: std :: os :: raw :: c_int ,) -> fpos_t , > , pub _write : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void , arg2 : * const :: std :: os :: raw :: c_char , arg3 : :: std :: os :: raw :: c_int ,) -> :: std :: os :: raw :: c_int , > , pub _ub : __sbuf , pub _extra : * mut __sFILEX , pub _ur : :: std :: os :: raw :: c_int , pub _ubuf : [:: std :: os :: raw :: c_uchar ; 3usize] , pub _nbuf : [:: std :: os :: raw :: c_uchar ; 1usize] , pub _lb : __sbuf , pub _blksize : :: std :: os :: raw :: c_int , pub _offset : fpos_t , }
pub type FILE = __sFILE ;
pub const FLEncoderFormat_kFLEncodeFleece : FLEncoderFormat = 0 ;
pub const FLEncoderFormat_kFLEncodeJSON : FLEncoderFormat = 1 ;
pub const FLEncoderFormat_kFLEncodeJSON5 : FLEncoderFormat = 2 ;
pub type FLEncoderFormat = :: std :: os :: raw :: c_uint ;
extern "C" { pub fn FLEncoder_New () -> FLEncoder ; }
extern "C" { pub fn FLEncoder_NewWithOptions (format : FLEncoderFormat , reserveSize : usize , uniqueStrings : bool ,) -> FLEncoder ; }
extern "C" { pub fn FLEncoder_NewWritingToFile (arg1 : * mut FILE , uniqueStrings : bool) -> FLEncoder ; }
extern "C" { pub fn FLEncoder_Free (arg1 : FLEncoder) ; }
extern "C" { pub fn FLEncoder_SetSharedKeys (arg1 : FLEncoder , arg2 : FLSharedKeys) ; }
extern "C" { pub fn FLEncoder_SetExtraInfo (arg1 : FLEncoder , info : * mut :: std :: os :: raw :: c_void) ; }
extern "C" { pub fn FLEncoder_GetExtraInfo (arg1 : FLEncoder) -> * mut :: std :: os :: raw :: c_void ; }
extern "C" { pub fn FLEncoder_Reset (arg1 : FLEncoder) ; }
extern "C" { pub fn FLEncoder_BytesWritten (arg1 : FLEncoder) -> usize ; }
extern "C" { pub fn FLEncoder_WriteNull (arg1 : FLEncoder) -> bool ; }
extern "C" { pub fn FLEncoder_WriteUndefined (arg1 : FLEncoder) -> bool ; }
extern "C" { pub fn FLEncoder_WriteBool (arg1 : FLEncoder , arg2 : bool) -> bool ; }
extern "C" { pub fn FLEncoder_WriteInt (arg1 : FLEncoder , arg2 : i64) -> bool ; }
extern "C" { pub fn FLEncoder_WriteUInt (arg1 : FLEncoder , arg2 : u64) -> bool ; }
extern "C" { pub fn FLEncoder_WriteFloat (arg1 : FLEncoder , arg2 : f32) -> bool ; }
extern "C" { pub fn FLEncoder_WriteDouble (arg1 : FLEncoder , arg2 : f64) -> bool ; }
extern "C" { pub fn FLEncoder_WriteString (arg1 : FLEncoder , arg2 : FLString) -> bool ; }
extern "C" { pub fn FLEncoder_WriteDateString (encoder : FLEncoder , ts : FLTimestamp , asUTC : bool) -> bool ; }
extern "C" { pub fn FLEncoder_WriteData (arg1 : FLEncoder , arg2 : FLSlice) -> bool ; }
extern "C" { pub fn FLEncoder_WriteValue (arg1 : FLEncoder , arg2 : FLValue) -> bool ; }
extern "C" { pub fn FLEncoder_BeginArray (arg1 : FLEncoder , reserveCount : usize) -> bool ; }
extern "C" { pub fn FLEncoder_EndArray (arg1 : FLEncoder) -> bool ; }
extern "C" { pub fn FLEncoder_BeginDict (arg1 : FLEncoder , reserveCount : usize) -> bool ; }
extern "C" { pub fn FLEncoder_WriteKey (arg1 : FLEncoder , arg2 : FLString) -> bool ; }
extern "C" { pub fn FLEncoder_WriteKeyValue (arg1 : FLEncoder , arg2 : FLValue) -> bool ; }
extern "C" { pub fn FLEncoder_EndDict (arg1 : FLEncoder) -> bool ; }
extern "C" { pub fn FLEncoder_WriteRaw (arg1 : FLEncoder , arg2 : FLSlice) -> bool ; }
extern "C" { pub fn FLEncoder_FinishDoc (arg1 : FLEncoder , outError : * mut FLError) -> FLDoc ; }
extern "C" { pub fn FLEncoder_Finish (arg1 : FLEncoder , outError : * mut FLError) -> FLSliceResult ; }
extern "C" { pub fn FLEncoder_GetError (arg1 : FLEncoder) -> FLError ; }
extern "C" { pub fn FLEncoder_GetErrorMessage (arg1 : FLEncoder) -> * const :: std :: os :: raw :: c_char ; }
extern "C" { pub fn FLValue_ToJSON (arg1 : FLValue) -> FLStringResult ; }
extern "C" { pub fn FLValue_ToJSON5 (arg1 : FLValue) -> FLStringResult ; }
extern "C" { pub fn FLValue_ToJSONX (v : FLValue , json5 : bool , canonicalForm : bool) -> FLStringResult ; }
extern "C" { pub fn FLDoc_FromJSON (json : FLSlice , outError : * mut FLError) -> FLDoc ; }
extern "C" { pub fn FLMutableArray_NewFromJSON (json : FLString , outError : * mut FLError) -> FLMutableArray ; }
extern "C" { pub fn FLMutableDict_NewFromJSON (json : FLString , outError : * mut FLError) -> FLMutableDict ; }
extern "C" { pub fn FLEncoder_ConvertJSON (arg1 : FLEncoder , json : FLSlice) -> bool ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLKeyPath { _unused : [u8 ; 0] , }
pub type FLKeyPath = * mut _FLKeyPath ;
extern "C" { pub fn FLKeyPath_New (specifier : FLSlice , outError : * mut FLError) -> FLKeyPath ; }
extern "C" { pub fn FLKeyPath_Free (arg1 : FLKeyPath) ; }
extern "C" { pub fn FLKeyPath_Eval (arg1 : FLKeyPath , root : FLValue) -> FLValue ; }
extern "C" { pub fn FLKeyPath_EvalOnce (specifier : FLSlice , root : FLValue , outError : * mut FLError) -> FLValue ; }
extern "C" { pub fn FLKeyPath_ToString (path : FLKeyPath) -> FLStringResult ; }
extern "C" { pub fn FLKeyPath_Equals (path1 : FLKeyPath , path2 : FLKeyPath) -> bool ; }
extern "C" { pub fn FLKeyPath_GetElement (arg1 : FLKeyPath , i : usize , outDictKey : * mut FLSlice , outArrayIndex : * mut i32 ,) -> bool ; }
# [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] pub enum FLValueType { kFLUndefined = - 1 , kFLNull = 0 , kFLBoolean = 1 , kFLNumber = 2 , kFLString = 3 , kFLData = 4 , kFLArray = 5 , kFLDict = 6 , }
extern "C" { pub static kFLNullValue : FLValue ; }
extern "C" { pub static kFLUndefinedValue : FLValue ; }
extern "C" { pub fn FLValue_GetType (arg1 : FLValue) -> FLValueType ; }
extern "C" { pub fn FLValue_IsInteger (arg1 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_IsUnsigned (arg1 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_IsDouble (arg1 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_AsBool (arg1 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_AsInt (arg1 : FLValue) -> i64 ; }
extern "C" { pub fn FLValue_AsUnsigned (arg1 : FLValue) -> u64 ; }
extern "C" { pub fn FLValue_AsFloat (arg1 : FLValue) -> f32 ; }
extern "C" { pub fn FLValue_AsDouble (arg1 : FLValue) -> f64 ; }
extern "C" { pub fn FLValue_AsString (arg1 : FLValue) -> FLString ; }
extern "C" { pub fn FLValue_AsTimestamp (arg1 : FLValue) -> FLTimestamp ; }
extern "C" { pub fn FLValue_AsData (arg1 : FLValue) -> FLSlice ; }
extern "C" { pub fn FLValue_AsArray (arg1 : FLValue) -> FLArray ; }
extern "C" { pub fn FLValue_AsDict (arg1 : FLValue) -> FLDict ; }
extern "C" { pub fn FLValue_ToString (arg1 : FLValue) -> FLStringResult ; }
extern "C" { pub fn FLValue_IsEqual (v1 : FLValue , v2 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_IsMutable (arg1 : FLValue) -> bool ; }
extern "C" { pub fn FLValue_Retain (arg1 : FLValue) -> FLValue ; }
extern "C" { pub fn FLValue_Release (arg1 : FLValue) ; }
pub const FLCopyFlags_kFLDefaultCopy : FLCopyFlags = 0 ;
pub const FLCopyFlags_kFLDeepCopy : FLCopyFlags = 1 ;
pub const FLCopyFlags_kFLCopyImmutables : FLCopyFlags = 2 ;
pub const FLCopyFlags_kFLDeepCopyImmutables : FLCopyFlags = 3 ;
pub type FLCopyFlags = :: std :: os :: raw :: c_uint ;
extern "C" { pub fn FLArray_MutableCopy (arg1 : FLArray , arg2 : FLCopyFlags) -> FLMutableArray ; }
extern "C" { pub fn FLMutableArray_New () -> FLMutableArray ; }
extern "C" { pub fn FLMutableArray_GetSource (arg1 : FLMutableArray) -> FLArray ; }
extern "C" { pub fn FLMutableArray_IsChanged (arg1 : FLMutableArray) -> bool ; }
extern "C" { pub fn FLMutableArray_SetChanged (arg1 : FLMutableArray , changed : bool) ; }
extern "C" { pub fn FLMutableArray_Insert (array : FLMutableArray , firstIndex : u32 , count : u32) ; }
extern "C" { pub fn FLMutableArray_Remove (array : FLMutableArray , firstIndex : u32 , count : u32) ; }
extern "C" { pub fn FLMutableArray_Resize (array : FLMutableArray , size : u32) ; }
extern "C" { pub fn FLMutableArray_GetMutableArray (arg1 : FLMutableArray , index : u32) -> FLMutableArray ; }
extern "C" { pub fn FLMutableArray_GetMutableDict (arg1 : FLMutableArray , index : u32) -> FLMutableDict ; }
extern "C" { pub fn FLDict_MutableCopy (source : FLDict , arg1 : FLCopyFlags) -> FLMutableDict ; }
extern "C" { pub fn FLMutableDict_New () -> FLMutableDict ; }
extern "C" { pub fn FLMutableDict_GetSource (arg1 : FLMutableDict) -> FLDict ; }
extern "C" { pub fn FLMutableDict_IsChanged (arg1 : FLMutableDict) -> bool ; }
extern "C" { pub fn FLMutableDict_SetChanged (arg1 : FLMutableDict , arg2 : bool) ; }
extern "C" { pub fn FLMutableDict_Remove (arg1 : FLMutableDict , key : FLString) ; }
extern "C" { pub fn FLMutableDict_RemoveAll (arg1 : FLMutableDict) ; }
extern "C" { pub fn FLMutableDict_GetMutableArray (arg1 : FLMutableDict , key : FLString) -> FLMutableArray ; }
extern "C" { pub fn FLMutableDict_GetMutableDict (arg1 : FLMutableDict , key : FLString) -> FLMutableDict ; }
extern "C" { pub fn FLValue_NewString (arg1 : FLString) -> FLValue ; }
extern "C" { pub fn FLValue_NewData (arg1 : FLSlice) -> FLValue ; }
extern "C" { pub fn FLMutableArray_Set (arg1 : FLMutableArray , index : u32) -> FLSlot ; }
extern "C" { pub fn FLMutableArray_Append (arg1 : FLMutableArray) -> FLSlot ; }
extern "C" { pub fn FLMutableDict_Set (arg1 : FLMutableDict , key : FLString) -> FLSlot ; }
extern "C" { pub fn FLSlot_SetNull (arg1 : FLSlot) ; }
extern "C" { pub fn FLSlot_SetBool (arg1 : FLSlot , arg2 : bool) ; }
extern "C" { pub fn FLSlot_SetInt (arg1 : FLSlot , arg2 : i64) ; }
extern "C" { pub fn FLSlot_SetUInt (arg1 : FLSlot , arg2 : u64) ; }
extern "C" { pub fn FLSlot_SetFloat (arg1 : FLSlot , arg2 : f32) ; }
extern "C" { pub fn FLSlot_SetDouble (arg1 : FLSlot , arg2 : f64) ; }
extern "C" { pub fn FLSlot_SetString (arg1 : FLSlot , arg2 : FLString) ; }
extern "C" { pub fn FLSlot_SetData (arg1 : FLSlot , arg2 : FLSlice) ; }
extern "C" { pub fn FLSlot_SetValue (arg1 : FLSlot , arg2 : FLValue) ; }
extern "C" { pub fn FLCreateJSONDelta (old : FLValue , nuu : FLValue) -> FLSliceResult ; }
extern "C" { pub fn FLEncodeJSONDelta (old : FLValue , nuu : FLValue , jsonEncoder : FLEncoder) -> bool ; }
extern "C" { pub fn FLApplyJSONDelta (old : FLValue , jsonDelta : FLSlice , outError : * mut FLError ,) -> FLSliceResult ; }
extern "C" { pub fn FLEncodeApplyingJSONDelta (old : FLValue , jsonDelta : FLSlice , encoder : FLEncoder) -> bool ; }
extern "C" { pub fn FLSharedKeys_New () -> FLSharedKeys ; }
pub type FLSharedKeysReadCallback = :: std :: option :: Option < unsafe extern "C" fn (context : * mut :: std :: os :: raw :: c_void , arg1 : FLSharedKeys) -> bool , > ;
extern "C" { pub fn FLSharedKeys_NewWithRead (arg1 : FLSharedKeysReadCallback , context : * mut :: std :: os :: raw :: c_void ,) -> FLSharedKeys ; }
extern "C" { pub fn FLSharedKeys_GetStateData (arg1 : FLSharedKeys) -> FLSliceResult ; }
extern "C" { pub fn FLSharedKeys_LoadStateData (arg1 : FLSharedKeys , arg2 : FLSlice) -> bool ; }
extern "C" { pub fn FLSharedKeys_WriteState (arg1 : FLSharedKeys , arg2 : FLEncoder) ; }
extern "C" { pub fn FLSharedKeys_LoadState (arg1 : FLSharedKeys , arg2 : FLValue) -> bool ; }
extern "C" { pub fn FLSharedKeys_Encode (arg1 : FLSharedKeys , arg2 : FLString , add : bool ,) -> :: std :: os :: raw :: c_int ; }
extern "C" { pub fn FLSharedKeys_Decode (arg1 : FLSharedKeys , key : :: std :: os :: raw :: c_int) -> FLString ; }
extern "C" { pub fn FLSharedKeys_Count (arg1 : FLSharedKeys) -> :: std :: os :: raw :: c_uint ; }
extern "C" { pub fn FLSharedKeys_RevertToCount (arg1 : FLSharedKeys , oldCount : :: std :: os :: raw :: c_uint) ; }
extern "C" { pub fn FLSharedKeys_Retain (arg1 : FLSharedKeys) -> FLSharedKeys ; }
extern "C" { pub fn FLSharedKeys_Release (arg1 : FLSharedKeys) ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct _FLSharedKeyScope { _unused : [u8 ; 0] , }
pub type FLSharedKeyScope = * mut _FLSharedKeyScope ;
extern "C" { pub fn FLSharedKeyScope_WithRange (range : FLSlice , arg1 : FLSharedKeys) -> FLSharedKeyScope ; }
extern "C" { pub fn FLSharedKeyScope_Free (arg1 : FLSharedKeyScope) ; }
extern "C" { pub fn FLValue_FromData (data : FLSlice , trust : FLTrust) -> FLValue ; }
extern "C" { pub fn FLJSON5_ToJSON (json5 : FLString , outErrorMessage : * mut FLStringResult , outErrorPos : * mut usize , outError : * mut FLError ,) -> FLStringResult ; }
extern "C" { pub fn FLData_ConvertJSON (json : FLSlice , outError : * mut FLError) -> FLSliceResult ; }
extern "C" { pub fn FLEncoder_Amend (e : FLEncoder , base : FLSlice , reuseStrings : bool , externPointers : bool) ; }
extern "C" { pub fn FLEncoder_GetBase (arg1 : FLEncoder) -> FLSlice ; }
extern "C" { pub fn FLEncoder_SuppressTrailer (arg1 : FLEncoder) ; }
extern "C" { pub fn FLEncoder_GetNextWritePos (arg1 : FLEncoder) -> usize ; }
extern "C" { pub fn FLEncoder_LastValueWritten (arg1 : FLEncoder) -> isize ; }
extern "C" { pub fn FLEncoder_WriteValueAgain (arg1 : FLEncoder , preWrittenValue : isize) ; }
extern "C" { pub fn FLEncoder_Snip (arg1 : FLEncoder) -> FLSliceResult ; }
extern "C" { pub fn FLEncoder_FinishItem (arg1 : FLEncoder) -> usize ; }
extern "C" { pub fn FLJSONEncoder_NextDocument (arg1 : FLEncoder) ; }
extern "C" { pub fn FLDump (arg1 : FLValue) -> * const :: std :: os :: raw :: c_char ; }
extern "C" { pub fn FLDumpData (data : FLSlice) -> * const :: std :: os :: raw :: c_char ; }
extern "C" { pub fn FLData_Dump (data : FLSlice) -> FLStringResult ; }
pub const kNilOptions : _bindgen_ty_2 = 0 ;
pub type _bindgen_ty_2 = :: std :: os :: raw :: c_uint ;
pub const kVariableLengthArray : _bindgen_ty_3 = 1 ;
pub type _bindgen_ty_3 = :: std :: os :: raw :: c_uint ;
pub const kUnknownType : _bindgen_ty_4 = 1061109567 ;
pub type _bindgen_ty_4 = :: std :: os :: raw :: c_uint ;
extern "C" { pub static mut kCFCoreFoundationVersionNumber : f64 ; }
pub type CFIndex = :: std :: os :: raw :: c_long ;
pub const kCFCompareLessThan : _bindgen_ty_7 = - 1 ;
pub const kCFCompareEqualTo : _bindgen_ty_7 = 0 ;
pub const kCFCompareGreaterThan : _bindgen_ty_7 = 1 ;
pub type _bindgen_ty_7 = :: std :: os :: raw :: c_int ;
pub const kCFNotFound : CFIndex = - 1 ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __CFNull { _unused : [u8 ; 0] , }
pub type CFNullRef = * const __CFNull ;
extern "C" { pub static kCFNull : CFNullRef ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct __CFAllocator { _unused : [u8 ; 0] , }
pub type CFAllocatorRef = * const __CFAllocator ;
extern "C" { pub static kCFAllocatorDefault : CFAllocatorRef ; }
extern "C" { pub static kCFAllocatorSystemDefault : CFAllocatorRef ; }
extern "C" { pub static kCFAllocatorMalloc : CFAllocatorRef ; }
extern "C" { pub static kCFAllocatorMallocZone : CFAllocatorRef ; }
extern "C" { pub static kCFAllocatorNull : CFAllocatorRef ; }
extern "C" { pub static kCFAllocatorUseContext : CFAllocatorRef ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ErrorDomain(pub u8);
impl C4ErrorDomain {
    pub const LiteCoreDomain: C4ErrorDomain = C4ErrorDomain(1);
    pub const POSIXDomain: C4ErrorDomain = C4ErrorDomain(2);
    pub const SQLiteDomain: C4ErrorDomain = C4ErrorDomain(3);
    pub const FleeceDomain: C4ErrorDomain = C4ErrorDomain(4);
    pub const NetworkDomain: C4ErrorDomain = C4ErrorDomain(5);
    pub const WebSocketDomain: C4ErrorDomain = C4ErrorDomain(6);
    pub const MbedTLSDomain: C4ErrorDomain = C4ErrorDomain(7);
    pub const kC4MaxErrorDomainPlus1: C4ErrorDomain = C4ErrorDomain(8);
}

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ErrorCode(pub i32);
impl C4ErrorCode {
    pub const kC4ErrorAssertionFailed: C4ErrorCode = C4ErrorCode(1);
    pub const kC4ErrorUnimplemented: C4ErrorCode = C4ErrorCode(2);
    pub const kC4ErrorUnsupportedEncryption: C4ErrorCode = C4ErrorCode(3);
    pub const kC4ErrorBadRevisionID: C4ErrorCode = C4ErrorCode(4);
    pub const kC4ErrorCorruptRevisionData: C4ErrorCode = C4ErrorCode(5);
    pub const kC4ErrorNotOpen: C4ErrorCode = C4ErrorCode(6);
    pub const kC4ErrorNotFound: C4ErrorCode = C4ErrorCode(7);
    pub const kC4ErrorConflict: C4ErrorCode = C4ErrorCode(8);
    pub const kC4ErrorInvalidParameter: C4ErrorCode = C4ErrorCode(9);
    pub const kC4ErrorUnexpectedError: C4ErrorCode = C4ErrorCode(10);
    pub const kC4ErrorCantOpenFile: C4ErrorCode = C4ErrorCode(11);
    pub const kC4ErrorIOError: C4ErrorCode = C4ErrorCode(12);
    pub const kC4ErrorMemoryError: C4ErrorCode = C4ErrorCode(13);
    pub const kC4ErrorNotWriteable: C4ErrorCode = C4ErrorCode(14);
    pub const kC4ErrorCorruptData: C4ErrorCode = C4ErrorCode(15);
    pub const kC4ErrorBusy: C4ErrorCode = C4ErrorCode(16);
    pub const kC4ErrorNotInTransaction: C4ErrorCode = C4ErrorCode(17);
    pub const kC4ErrorTransactionNotClosed: C4ErrorCode = C4ErrorCode(18);
    pub const kC4ErrorUnsupported: C4ErrorCode = C4ErrorCode(19);
    pub const kC4ErrorNotADatabaseFile: C4ErrorCode = C4ErrorCode(20);
    pub const kC4ErrorWrongFormat: C4ErrorCode = C4ErrorCode(21);
    pub const kC4ErrorCrypto: C4ErrorCode = C4ErrorCode(22);
    pub const kC4ErrorInvalidQuery: C4ErrorCode = C4ErrorCode(23);
    pub const kC4ErrorMissingIndex: C4ErrorCode = C4ErrorCode(24);
    pub const kC4ErrorInvalidQueryParam: C4ErrorCode = C4ErrorCode(25);
    pub const kC4ErrorRemoteError: C4ErrorCode = C4ErrorCode(26);
    pub const kC4ErrorDatabaseTooOld: C4ErrorCode = C4ErrorCode(27);
    pub const kC4ErrorDatabaseTooNew: C4ErrorCode = C4ErrorCode(28);
    pub const kC4ErrorBadDocID: C4ErrorCode = C4ErrorCode(29);
    pub const kC4ErrorCantUpgradeDatabase: C4ErrorCode = C4ErrorCode(30);
    pub const kC4ErrorDeltaBaseUnknown: C4ErrorCode = C4ErrorCode(31);
    pub const kC4ErrorCorruptDelta: C4ErrorCode = C4ErrorCode(32);
    pub const kC4NumErrorCodesPlus1: C4ErrorCode = C4ErrorCode(33);
}

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4NetworkErrorCode(pub i32);
impl C4NetworkErrorCode {
    pub const kC4NetErrDNSFailure: C4NetworkErrorCode = C4NetworkErrorCode(1);
    pub const kC4NetErrUnknownHost: C4NetworkErrorCode = C4NetworkErrorCode(2);
    pub const kC4NetErrTimeout: C4NetworkErrorCode = C4NetworkErrorCode(3);
    pub const kC4NetErrInvalidURL: C4NetworkErrorCode = C4NetworkErrorCode(4);
    pub const kC4NetErrTooManyRedirects: C4NetworkErrorCode = C4NetworkErrorCode(5);
    pub const kC4NetErrTLSHandshakeFailed: C4NetworkErrorCode = C4NetworkErrorCode(6);
    pub const kC4NetErrTLSCertExpired: C4NetworkErrorCode = C4NetworkErrorCode(7);
    pub const kC4NetErrTLSCertUntrusted: C4NetworkErrorCode = C4NetworkErrorCode(8);
    pub const kC4NetErrTLSCertRequiredByPeer: C4NetworkErrorCode = C4NetworkErrorCode(9);
    pub const kC4NetErrTLSCertRejectedByPeer: C4NetworkErrorCode = C4NetworkErrorCode(10);
    pub const kC4NetErrTLSCertUnknownRoot: C4NetworkErrorCode = C4NetworkErrorCode(11);
    pub const kC4NetErrInvalidRedirect: C4NetworkErrorCode = C4NetworkErrorCode(12);
    pub const kC4NetErrUnknown: C4NetworkErrorCode = C4NetworkErrorCode(13);
    pub const kC4NetErrTLSCertRevoked: C4NetworkErrorCode = C4NetworkErrorCode(14);
    pub const kC4NetErrTLSCertNameMismatch: C4NetworkErrorCode = C4NetworkErrorCode(15);
    pub const kC4NetErrNetworkReset: C4NetworkErrorCode = C4NetworkErrorCode(16);
    pub const kC4NetErrConnectionAborted: C4NetworkErrorCode = C4NetworkErrorCode(17);
    pub const kC4NetErrConnectionReset: C4NetworkErrorCode = C4NetworkErrorCode(18);
    pub const kC4NetErrConnectionRefused: C4NetworkErrorCode = C4NetworkErrorCode(19);
    pub const kC4NetErrNetworkDown: C4NetworkErrorCode = C4NetworkErrorCode(20);
    pub const kC4NetErrNetworkUnreachable: C4NetworkErrorCode = C4NetworkErrorCode(21);
    pub const kC4NetErrNotConnected: C4NetworkErrorCode = C4NetworkErrorCode(22);
    pub const kC4NetErrHostDown: C4NetworkErrorCode = C4NetworkErrorCode(23);
    pub const kC4NetErrHostUnreachable: C4NetworkErrorCode = C4NetworkErrorCode(24);
    pub const kC4NetErrAddressNotAvailable: C4NetworkErrorCode = C4NetworkErrorCode(25);
    pub const kC4NetErrBrokenPipe: C4NetworkErrorCode = C4NetworkErrorCode(26);
    pub const kC4NetErrUnknownInterface: C4NetworkErrorCode = C4NetworkErrorCode(27);
    pub const kC4NumNetErrorCodesPlus1: C4NetworkErrorCode = C4NetworkErrorCode(28);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Error { pub domain : C4ErrorDomain , pub code : :: std :: os :: raw :: c_int , pub internal_info : :: std :: os :: raw :: c_uint , }
extern "C" { pub fn c4error_getMessage (error : C4Error) -> FLStringResult ; }
extern "C" { pub fn c4error_getDescription (error : C4Error) -> FLSliceResult ; }
extern "C" { pub fn c4error_getDescriptionC (error : C4Error , outBuffer : * mut :: std :: os :: raw :: c_char , bufferSize : usize ,) -> * mut :: std :: os :: raw :: c_char ; }
extern "C" { pub fn c4error_setCaptureBacktraces (arg1 : bool) ; }
extern "C" { pub fn c4error_getCaptureBacktraces () -> bool ; }
extern "C" { pub fn c4error_getBacktrace (error : C4Error) -> FLStringResult ; }
extern "C" { pub fn c4error_make (domain : C4ErrorDomain , code : :: std :: os :: raw :: c_int , message : FLString ,) -> C4Error ; }
extern "C" { pub fn c4error_printf (domain : C4ErrorDomain , code : :: std :: os :: raw :: c_int , format : * const :: std :: os :: raw :: c_char , ...) -> C4Error ; }
extern "C" { pub fn c4error_vprintf (domain : C4ErrorDomain , code : :: std :: os :: raw :: c_int , format : * const :: std :: os :: raw :: c_char , args : va_list ,) -> C4Error ; }
extern "C" { pub fn c4error_return (domain : C4ErrorDomain , code : :: std :: os :: raw :: c_int , message : FLString , outError : * mut C4Error ,) ; }
extern "C" { pub fn c4error_mayBeTransient (err : C4Error) -> bool ; }
extern "C" { pub fn c4error_mayBeNetworkDependent (err : C4Error) -> bool ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4LogLevel(pub i8);
impl C4LogLevel {
    pub const kC4LogDebug: C4LogLevel = C4LogLevel(0);
    pub const kC4LogVerbose: C4LogLevel = C4LogLevel(1);
    pub const kC4LogInfo: C4LogLevel = C4LogLevel(2);
    pub const kC4LogWarning: C4LogLevel = C4LogLevel(3);
    pub const kC4LogError: C4LogLevel = C4LogLevel(4);
    pub const kC4LogNone: C4LogLevel = C4LogLevel(5);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct c4LogDomain { _unused : [u8 ; 0] , }
pub type C4LogDomain = * mut c4LogDomain ;
extern "C" { pub static kC4DefaultLog : C4LogDomain ; }
extern "C" { pub static mut kC4DatabaseLog : C4LogDomain ; }
extern "C" { pub static mut kC4QueryLog : C4LogDomain ; }
extern "C" { pub static mut kC4SyncLog : C4LogDomain ; }
extern "C" { pub static mut kC4WebSocketLog : C4LogDomain ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4LogFileOptions { pub log_level : C4LogLevel , pub base_path : FLString , pub max_size_bytes : i64 , pub max_rotate_count : i32 , pub use_plaintext : bool , pub header : FLString , }
extern "C" { pub fn c4log_writeToBinaryFile (options : C4LogFileOptions , error : * mut C4Error) -> bool ; }
extern "C" { pub fn c4log_binaryFilePath () -> FLStringResult ; }
extern "C" { pub fn c4log_flushLogFiles () ; }
extern "C" { pub fn c4log_binaryFileLevel () -> C4LogLevel ; }
extern "C" { pub fn c4log_setBinaryFileLevel (level : C4LogLevel) ; }
extern "C" { pub fn c4log_writeToCallback (level : C4LogLevel , callback : :: std :: option :: Option < unsafe extern "C" fn (arg1 : C4LogDomain , arg2 : C4LogLevel , arg3 : * const :: std :: os :: raw :: c_char , arg4 : va_list ,) , > , preformatted : bool ,) ; }
extern "C" { pub fn c4log_getCallback () -> :: std :: option :: Option < unsafe extern "C" fn (arg1 : C4LogDomain , arg2 : C4LogLevel , arg3 : * const :: std :: os :: raw :: c_char , arg4 : va_list ,) , > ; }
extern "C" { pub fn c4log_callbackLevel () -> C4LogLevel ; }
extern "C" { pub fn c4log_setCallbackLevel (level : C4LogLevel) ; }
extern "C" { pub fn c4log_getDomain (name : * const :: std :: os :: raw :: c_char , create : bool) -> C4LogDomain ; }
extern "C" { pub fn c4log_getDomainName (arg1 : C4LogDomain) -> * const :: std :: os :: raw :: c_char ; }
extern "C" { pub fn c4log_getLevel (arg1 : C4LogDomain) -> C4LogLevel ; }
extern "C" { pub fn c4log_willLog (arg1 : C4LogDomain , arg2 : C4LogLevel) -> bool ; }
extern "C" { pub fn c4log_setLevel (c4Domain : C4LogDomain , level : C4LogLevel) ; }
extern "C" { pub fn c4log_warnOnErrors (arg1 : bool) ; }
extern "C" { pub fn c4log_getWarnOnErrors () -> bool ; }
extern "C" { pub fn c4log_enableFatalExceptionBacktrace () ; }
extern "C" { pub fn c4log (domain : C4LogDomain , level : C4LogLevel , fmt : * const :: std :: os :: raw :: c_char , ...) ; }
extern "C" { pub fn c4vlog (domain : C4LogDomain , level : C4LogLevel , fmt : * const :: std :: os :: raw :: c_char , args : va_list ,) ; }
extern "C" { pub fn c4slog (domain : C4LogDomain , level : C4LogLevel , msg : FLString) ; }
pub type C4Slice = FLSlice ;
pub type C4HeapSlice = FLHeapSlice ;
pub type C4SliceResult = FLSliceResult ;
pub type C4String = C4Slice ;
pub type C4HeapString = C4HeapSlice ;
pub type C4StringResult = C4SliceResult ;
pub type C4SequenceNumber = u64 ;
pub type C4Timestamp = i64 ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ExtraInfo { pub pointer : * mut :: std :: os :: raw :: c_void , pub destructor : :: std :: option :: Option < unsafe extern "C" fn (ptr : * mut :: std :: os :: raw :: c_void) > , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4BlobStore { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Cert { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Collection { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4CollectionObserver { _unused : [u8 ; 0] , }
pub type C4DatabaseObserver = C4CollectionObserver ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Database { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DocumentObserver { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DocEnumerator { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4KeyPair { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Listener { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Query { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4QueryObserver { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ReadStream { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Replicator { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Socket { _unused : [u8 ; 0] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4WriteStream { _unused : [u8 ; 0] , }
extern "C" { pub fn c4base_retain (obj : * mut :: std :: os :: raw :: c_void) -> * mut :: std :: os :: raw :: c_void ; }
extern "C" { pub fn c4base_release (obj : * mut :: std :: os :: raw :: c_void) ; }
extern "C" { pub fn c4doc_retain (arg1 : * mut C4Document) -> * mut C4Document ; }
extern "C" { pub fn c4queryenum_retain (arg1 : * mut C4QueryEnumerator) -> * mut C4QueryEnumerator ; }
extern "C" { pub fn c4socket_retain (arg1 : * mut C4Socket) -> * mut C4Socket ; }
extern "C" { pub fn c4doc_release (arg1 : * mut C4Document) ; }
extern "C" { pub fn c4queryenum_release (arg1 : * mut C4QueryEnumerator) ; }
extern "C" { pub fn c4socket_release (arg1 : * mut C4Socket) ; }
extern "C" { pub fn c4dbobs_free (arg1 : * mut C4CollectionObserver) ; }
extern "C" { pub fn c4docobs_free (arg1 : * mut C4DocumentObserver) ; }
extern "C" { pub fn c4enum_free (arg1 : * mut C4DocEnumerator) ; }
extern "C" { pub fn c4listener_free (arg1 : * mut C4Listener) ; }
extern "C" { pub fn c4queryobs_free (arg1 : * mut C4QueryObserver) ; }
extern "C" { pub fn c4raw_free (arg1 : * mut C4RawDocument) ; }
extern "C" { pub fn c4repl_free (arg1 : * mut C4Replicator) ; }
extern "C" { pub fn c4stream_close (arg1 : * mut C4ReadStream) ; }
extern "C" { pub fn c4stream_closeWriter (arg1 : * mut C4WriteStream) ; }
extern "C" { pub fn c4_getObjectCount () -> :: std :: os :: raw :: c_int ; }
extern "C" { pub fn c4_dumpInstances () ; }
extern "C" { pub fn c4_getBuildInfo () -> C4StringResult ; }
extern "C" { pub fn c4_getVersion () -> C4StringResult ; }
extern "C" { pub fn c4_getEnvironmentInfo () -> C4SliceResult ; }
extern "C" { pub fn c4_now () -> C4Timestamp ; }
extern "C" { pub fn c4_setTempDir (path : C4String , err : * mut C4Error) -> bool ; }
extern "C" { pub fn c4_runAsyncTask (task : :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut :: std :: os :: raw :: c_void) > , context : * mut :: std :: os :: raw :: c_void ,) ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4BlobKey { pub bytes : [u8 ; 20usize] , }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4DatabaseFlags(pub u32);
impl C4DatabaseFlags {
    pub const kC4DB_Create: C4DatabaseFlags = C4DatabaseFlags(1);
    pub const kC4DB_ReadOnly: C4DatabaseFlags = C4DatabaseFlags(2);
    pub const kC4DB_AutoCompact: C4DatabaseFlags = C4DatabaseFlags(4);
    pub const kC4DB_VersionVectors: C4DatabaseFlags = C4DatabaseFlags(8);
    pub const kC4DB_NoUpgrade: C4DatabaseFlags = C4DatabaseFlags(32);
    pub const kC4DB_NonObservable: C4DatabaseFlags = C4DatabaseFlags(64);
}
impl std::ops::BitAnd for C4DatabaseFlags {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4DatabaseFlags {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4EncryptionAlgorithm(pub u32);
impl C4EncryptionAlgorithm {
    pub const kC4EncryptionNone: C4EncryptionAlgorithm = C4EncryptionAlgorithm(0);
    pub const kC4EncryptionAES256: C4EncryptionAlgorithm = C4EncryptionAlgorithm(1);
}

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4EncryptionKeySize(pub u64);
impl C4EncryptionKeySize {
    pub const kC4EncryptionKeySizeAES256: C4EncryptionKeySize = C4EncryptionKeySize(32);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4EncryptionKey { pub algorithm : C4EncryptionAlgorithm , pub bytes : [u8 ; 32usize] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DatabaseConfig2 { pub parentDirectory : C4Slice , pub flags : C4DatabaseFlags , pub encryptionKey : C4EncryptionKey , }
extern "C" { pub static kC4DatabaseFilenameExtension : * const :: std :: os :: raw :: c_char ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4UUID { pub bytes : [u8 ; 16usize] , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4CollectionSpec { pub name : C4String , pub scope : C4String , }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4MaintenanceType(pub u32);
impl C4MaintenanceType {
    pub const kC4Compact: C4MaintenanceType = C4MaintenanceType(0);
    pub const kC4Reindex: C4MaintenanceType = C4MaintenanceType(1);
    pub const kC4IntegrityCheck: C4MaintenanceType = C4MaintenanceType(2);
    pub const kC4QuickOptimize: C4MaintenanceType = C4MaintenanceType(3);
    pub const kC4FullOptimize: C4MaintenanceType = C4MaintenanceType(4);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4RawDocument { pub key : C4String , pub meta : C4String , pub body : C4String , }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4DocumentVersioning(pub u32);
impl C4DocumentVersioning {
    pub const kC4TreeVersioning_v2: C4DocumentVersioning = C4DocumentVersioning(0);
    pub const kC4TreeVersioning: C4DocumentVersioning = C4DocumentVersioning(1);
    pub const kC4VectorVersioning: C4DocumentVersioning = C4DocumentVersioning(2);
}
pub type C4StorageEngine = * const :: std :: os :: raw :: c_char ;
extern "C" { pub static kC4SQLiteStorageEngine : C4StorageEngine ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DatabaseConfig { pub flags : C4DatabaseFlags , pub storageEngine : C4StorageEngine , pub versioning : C4DocumentVersioning , pub encryptionKey : C4EncryptionKey , }
extern "C" { pub fn c4blob_keyFromString (str_ : C4String , arg1 : * mut C4BlobKey) -> bool ; }
extern "C" { pub fn c4blob_keyToString (arg1 : C4BlobKey) -> C4StringResult ; }
extern "C" { pub fn c4db_getBlobStore (db : * mut C4Database , outError : * mut C4Error) -> * mut C4BlobStore ; }
extern "C" { pub fn c4blob_openStore (dirPath : C4String , flags : C4DatabaseFlags , encryptionKey : * const C4EncryptionKey , outError : * mut C4Error ,) -> * mut C4BlobStore ; }
extern "C" { pub fn c4blob_freeStore (arg1 : * mut C4BlobStore) ; }
extern "C" { pub fn c4blob_deleteStore (arg1 : * mut C4BlobStore , arg2 : * mut C4Error) -> bool ; }
extern "C" { pub fn c4blob_getSize (arg1 : * mut C4BlobStore , arg2 : C4BlobKey) -> i64 ; }
extern "C" { pub fn c4blob_getContents (arg1 : * mut C4BlobStore , arg2 : C4BlobKey , arg3 : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4blob_getFilePath (arg1 : * mut C4BlobStore , arg2 : C4BlobKey , arg3 : * mut C4Error ,) -> C4StringResult ; }
extern "C" { pub fn c4blob_computeKey (contents : C4Slice) -> C4BlobKey ; }
extern "C" { pub fn c4blob_create (store : * mut C4BlobStore , contents : C4Slice , expectedKey : * const C4BlobKey , outKey : * mut C4BlobKey , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4blob_delete (arg1 : * mut C4BlobStore , arg2 : C4BlobKey , arg3 : * mut C4Error) -> bool ; }
extern "C" { pub fn c4blob_openReadStream (arg1 : * mut C4BlobStore , arg2 : C4BlobKey , arg3 : * mut C4Error ,) -> * mut C4ReadStream ; }
extern "C" { pub fn c4stream_read (stream : * mut C4ReadStream , buffer : * mut :: std :: os :: raw :: c_void , maxBytesToRead : usize , error : * mut C4Error ,) -> usize ; }
extern "C" { pub fn c4stream_getLength (arg1 : * mut C4ReadStream , arg2 : * mut C4Error) -> i64 ; }
extern "C" { pub fn c4stream_seek (arg1 : * mut C4ReadStream , position : u64 , arg2 : * mut C4Error) -> bool ; }
extern "C" { pub fn c4blob_openWriteStream (arg1 : * mut C4BlobStore , arg2 : * mut C4Error) -> * mut C4WriteStream ; }
extern "C" { pub fn c4stream_write (arg1 : * mut C4WriteStream , bytes : * const :: std :: os :: raw :: c_void , length : usize , arg2 : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4stream_bytesWritten (arg1 : * mut C4WriteStream) -> u64 ; }
extern "C" { pub fn c4stream_computeBlobKey (arg1 : * mut C4WriteStream) -> C4BlobKey ; }
extern "C" { pub fn c4stream_install (arg1 : * mut C4WriteStream , expectedKey : * const C4BlobKey , arg2 : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4cert_getValidTimespan (cert : * mut C4Cert , outCreated : * mut C4Timestamp , outExpires : * mut C4Timestamp ,) ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4DocumentFlags(pub u32);
impl C4DocumentFlags {
    pub const kDocDeleted: C4DocumentFlags = C4DocumentFlags(1);
    pub const kDocConflicted: C4DocumentFlags = C4DocumentFlags(2);
    pub const kDocHasAttachments: C4DocumentFlags = C4DocumentFlags(4);
    pub const kDocExists: C4DocumentFlags = C4DocumentFlags(4096);
}
impl std::ops::BitAnd for C4DocumentFlags {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4DocumentFlags {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4RevisionFlags(pub u8);
impl C4RevisionFlags {
    pub const kRevDeleted: C4RevisionFlags = C4RevisionFlags(1);
    pub const kRevLeaf: C4RevisionFlags = C4RevisionFlags(2);
    pub const kRevNew: C4RevisionFlags = C4RevisionFlags(4);
    pub const kRevHasAttachments: C4RevisionFlags = C4RevisionFlags(8);
    pub const kRevKeepBody: C4RevisionFlags = C4RevisionFlags(16);
    pub const kRevIsConflict: C4RevisionFlags = C4RevisionFlags(32);
    pub const kRevClosed: C4RevisionFlags = C4RevisionFlags(64);
    pub const kRevPurged: C4RevisionFlags = C4RevisionFlags(128);
}
impl std::ops::BitAnd for C4RevisionFlags {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4RevisionFlags {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }
pub type C4RemoteID = u32 ;

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4DocContentLevel(pub u8);
impl C4DocContentLevel {
    pub const kDocGetMetadata: C4DocContentLevel = C4DocContentLevel(0);
    pub const kDocGetCurrentRev: C4DocContentLevel = C4DocContentLevel(1);
    pub const kDocGetAll: C4DocContentLevel = C4DocContentLevel(2);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Revision { pub revID : C4HeapString , pub flags : C4RevisionFlags , pub sequence : C4SequenceNumber , }
pub type C4DocDeltaApplier = :: std :: option :: Option < unsafe extern "C" fn (context : * mut :: std :: os :: raw :: c_void , doc : * mut C4Document , delta : C4Slice , revFlags : * mut C4RevisionFlags , outError : * mut C4Error ,) -> C4SliceResult , > ;
# [repr (C)] # [derive (Debug)] pub struct C4DocPutRequest { pub body : C4String , pub docID : C4String , pub revFlags : C4RevisionFlags , pub existingRevision : bool , pub allowConflict : bool , pub history : * const C4String , pub historyCount : usize , pub save : bool , pub maxRevTreeDepth : u32 , pub remoteDBID : C4RemoteID , pub allocedBody : C4SliceResult , pub deltaCB : C4DocDeltaApplier , pub deltaCBContext : * mut :: std :: os :: raw :: c_void , pub deltaSourceRevID : C4String , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4CollectionChange { pub docID : C4HeapString , pub revID : C4HeapString , pub sequence : C4SequenceNumber , pub bodySize : u32 , pub flags : C4RevisionFlags , }
pub type C4DatabaseChange = C4CollectionChange ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4CollectionObservation { pub numChanges : u32 , pub external : bool , pub collection : * mut C4Collection , }

    #[repr(u32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum C4QueryLanguage {
    kC4JSONQuery = 0,
    kC4N1QLQuery = 1,
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4QueryOptions { pub rankFullText_DEPRECATED : bool , }
extern "C" { pub static kC4DefaultQueryOptions : C4QueryOptions ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4FullTextMatch { pub dataSource : u64 , pub property : u32 , pub term : u32 , pub start : u32 , pub length : u32 , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4QueryEnumerator { pub columns : FLArrayIterator , pub missingColumns : u64 , pub fullTextMatchCount : u32 , pub fullTextMatches : * const C4FullTextMatch , }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4IndexType(pub u32);
impl C4IndexType {
    pub const kC4ValueIndex: C4IndexType = C4IndexType(0);
    pub const kC4FullTextIndex: C4IndexType = C4IndexType(1);
    pub const kC4ArrayIndex: C4IndexType = C4IndexType(2);
    pub const kC4PredictiveIndex: C4IndexType = C4IndexType(3);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4IndexOptions { pub language : * const :: std :: os :: raw :: c_char , pub ignoreDiacritics : bool , pub disableStemming : bool , pub stopWords : * const :: std :: os :: raw :: c_char , }
extern "C" { pub fn c4db_getDefaultCollection (db : * mut C4Database , outError : * mut C4Error ,) -> * mut C4Collection ; }
extern "C" { pub fn c4db_hasCollection (db : * mut C4Database , spec : C4CollectionSpec) -> bool ; }
extern "C" { pub fn c4db_hasScope (db : * mut C4Database , name : C4String) -> bool ; }
extern "C" { pub fn c4db_getCollection (db : * mut C4Database , spec : C4CollectionSpec , outError : * mut C4Error ,) -> * mut C4Collection ; }
extern "C" { pub fn c4db_createCollection (db : * mut C4Database , spec : C4CollectionSpec , outError : * mut C4Error ,) -> * mut C4Collection ; }
extern "C" { pub fn c4db_deleteCollection (db : * mut C4Database , spec : C4CollectionSpec , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_collectionNames (db : * mut C4Database , inScope : C4String , outError : * mut C4Error ,) -> FLMutableArray ; }
extern "C" { pub fn c4db_scopeNames (db : * mut C4Database , outError : * mut C4Error) -> FLMutableArray ; }
extern "C" { pub fn c4coll_isValid (arg1 : * mut C4Collection) -> bool ; }
extern "C" { pub fn c4coll_getSpec (arg1 : * mut C4Collection) -> C4CollectionSpec ; }
extern "C" { pub fn c4coll_getDatabase (arg1 : * mut C4Collection) -> * mut C4Database ; }
extern "C" { pub fn c4coll_getDocumentCount (arg1 : * mut C4Collection) -> u64 ; }
extern "C" { pub fn c4coll_getLastSequence (arg1 : * mut C4Collection) -> C4SequenceNumber ; }
extern "C" { pub fn c4coll_getDoc (collection : * mut C4Collection , docID : C4String , mustExist : bool , content : C4DocContentLevel , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4coll_getDocBySequence (collection : * mut C4Collection , arg1 : C4SequenceNumber , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4coll_putDoc (collection : * mut C4Collection , request : * const C4DocPutRequest , outCommonAncestorIndex : * mut usize , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4coll_createDoc (collection : * mut C4Collection , docID : C4String , body : C4Slice , revisionFlags : C4RevisionFlags , error : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4coll_moveDoc (collection : * mut C4Collection , docID : C4String , toCollection : * mut C4Collection , newDocID : C4String , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4coll_purgeDoc (collection : * mut C4Collection , docID : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4coll_setDocExpiration (collection : * mut C4Collection , docID : C4String , timestamp : C4Timestamp , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4coll_getDocExpiration (collection : * mut C4Collection , docID : C4String , outError : * mut C4Error ,) -> C4Timestamp ; }
extern "C" { pub fn c4coll_nextDocExpiration (arg1 : * mut C4Collection) -> C4Timestamp ; }
extern "C" { pub fn c4coll_purgeExpiredDocs (arg1 : * mut C4Collection , arg2 : * mut C4Error) -> i64 ; }
extern "C" { pub fn c4coll_createIndex (collection : * mut C4Collection , name : C4String , indexSpec : C4String , queryLanguage : C4QueryLanguage , indexType : C4IndexType , indexOptions : * const C4IndexOptions , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4coll_deleteIndex (collection : * mut C4Collection , name : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4coll_getIndexesInfo (collection : * mut C4Collection , outError : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4key_setPassword (encryptionKey : * mut C4EncryptionKey , password : C4String , alg : C4EncryptionAlgorithm ,) -> bool ; }
extern "C" { pub fn c4key_setPasswordSHA1 (encryptionKey : * mut C4EncryptionKey , password : C4String , alg : C4EncryptionAlgorithm ,) -> bool ; }
extern "C" { pub fn c4db_exists (name : C4String , inDirectory : C4String) -> bool ; }
extern "C" { pub fn c4db_openNamed (name : C4String , config : * const C4DatabaseConfig2 , outError : * mut C4Error ,) -> * mut C4Database ; }
extern "C" { pub fn c4db_openAgain (db : * mut C4Database , outError : * mut C4Error) -> * mut C4Database ; }
extern "C" { pub fn c4db_copyNamed (sourcePath : C4String , destinationName : C4String , config : * const C4DatabaseConfig2 , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_close (database : * mut C4Database , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4db_delete (database : * mut C4Database , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4db_deleteNamed (dbName : C4String , inDirectory : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_rekey (database : * mut C4Database , newKey : * const C4EncryptionKey , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4_shutdown (outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4db_getName (arg1 : * mut C4Database) -> C4String ; }
extern "C" { pub fn c4db_getPath (arg1 : * mut C4Database) -> C4StringResult ; }
extern "C" { pub fn c4db_getConfig2 (database : * mut C4Database) -> * const C4DatabaseConfig2 ; }
extern "C" { pub fn c4db_getDocumentCount (database : * mut C4Database) -> u64 ; }
extern "C" { pub fn c4db_getLastSequence (database : * mut C4Database) -> C4SequenceNumber ; }
extern "C" { pub fn c4db_nextDocExpiration (database : * mut C4Database) -> C4Timestamp ; }
extern "C" { pub fn c4db_purgeExpiredDocs (db : * mut C4Database , arg1 : * mut C4Error) -> i64 ; }
extern "C" { pub fn c4db_getUUIDs (database : * mut C4Database , publicUUID : * mut C4UUID , privateUUID : * mut C4UUID , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_setExtraInfo (database : * mut C4Database , arg1 : C4ExtraInfo) ; }
extern "C" { pub fn c4db_getExtraInfo (database : * mut C4Database) -> C4ExtraInfo ; }
extern "C" { pub fn c4db_maintenance (database : * mut C4Database , type_ : C4MaintenanceType , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_beginTransaction (database : * mut C4Database , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4db_endTransaction (database : * mut C4Database , commit : bool , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_isInTransaction (database : * mut C4Database) -> bool ; }
extern "C" { pub fn c4raw_get (database : * mut C4Database , storeName : C4String , docID : C4String , outError : * mut C4Error ,) -> * mut C4RawDocument ; }
extern "C" { pub fn c4raw_put (database : * mut C4Database , storeName : C4String , key : C4String , meta : C4String , body : C4String , outError : * mut C4Error ,) -> bool ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Document { pub _internal1 : * mut :: std :: os :: raw :: c_void , pub _internal2 : * mut :: std :: os :: raw :: c_void , pub flags : C4DocumentFlags , pub docID : C4HeapString , pub revID : C4HeapString , pub sequence : C4SequenceNumber , pub selectedRev : C4Revision , pub extraInfo : C4ExtraInfo , }
extern "C" { pub fn c4doc_generateID (buffer : * mut :: std :: os :: raw :: c_char , bufferSize : usize ,) -> * mut :: std :: os :: raw :: c_char ; }
extern "C" { pub fn c4db_getDoc (database : * mut C4Database , docID : C4String , mustExist : bool , content : C4DocContentLevel , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_get (database : * mut C4Database , docID : C4String , mustExist : bool , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_getBySequence (database : * mut C4Database , arg1 : C4SequenceNumber , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_save (doc : * mut C4Document , maxRevTreeDepth : u32 , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4doc_selectRevision (doc : * mut C4Document , revID : C4String , withBody : bool , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4doc_selectCurrentRevision (doc : * mut C4Document) -> bool ; }
extern "C" { pub fn c4doc_loadRevisionBody (doc : * mut C4Document , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4doc_hasRevisionBody (doc : * mut C4Document) -> bool ; }
extern "C" { pub fn c4doc_getRevisionBody (doc : * mut C4Document) -> C4Slice ; }
extern "C" { pub fn c4doc_getRevisionHistory (doc : * mut C4Document , maxRevs : :: std :: os :: raw :: c_uint , backToRevs : * const C4String , backToRevsCount : :: std :: os :: raw :: c_uint ,) -> C4SliceResult ; }
extern "C" { pub fn c4doc_getSelectedRevIDGlobalForm (doc : * mut C4Document) -> C4SliceResult ; }
extern "C" { pub fn c4doc_selectParentRevision (doc : * mut C4Document) -> bool ; }
extern "C" { pub fn c4doc_selectNextRevision (doc : * mut C4Document) -> bool ; }
extern "C" { pub fn c4doc_selectNextLeafRevision (doc : * mut C4Document , includeDeleted : bool , withBody : bool , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4doc_selectCommonAncestorRevision (doc : * mut C4Document , rev1ID : C4String , rev2ID : C4String ,) -> bool ; }
extern "C" { pub fn c4db_getRemoteDBID (db : * mut C4Database , remoteAddress : C4String , canCreate : bool , outError : * mut C4Error ,) -> C4RemoteID ; }
extern "C" { pub fn c4db_getRemoteDBAddress (db : * mut C4Database , remoteID : C4RemoteID) -> C4SliceResult ; }
extern "C" { pub fn c4doc_getRemoteAncestor (doc : * mut C4Document , remoteDatabase : C4RemoteID ,) -> C4SliceResult ; }
extern "C" { pub fn c4doc_setRemoteAncestor (doc : * mut C4Document , remoteDatabase : C4RemoteID , revID : C4String , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4rev_getGeneration (revID : C4String) -> :: std :: os :: raw :: c_uint ; }
extern "C" { pub fn c4rev_equal (rev1 : C4Slice , rev2 : C4Slice) -> bool ; }
extern "C" { pub fn c4doc_purgeRevision (doc : * mut C4Document , revID : C4String , outError : * mut C4Error ,) -> i32 ; }
extern "C" { pub fn c4doc_resolveConflict (doc : * mut C4Document , winningRevID : C4String , losingRevID : C4String , mergedBody : C4Slice , mergedFlags : C4RevisionFlags , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_purgeDoc (database : * mut C4Database , docID : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4doc_setExpiration (db : * mut C4Database , docID : C4String , timestamp : C4Timestamp , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4doc_getExpiration (db : * mut C4Database , docID : C4String , outError : * mut C4Error ,) -> C4Timestamp ; }
extern "C" { pub fn c4doc_put (database : * mut C4Database , request : * const C4DocPutRequest , outCommonAncestorIndex : * mut usize , outError : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_create (db : * mut C4Database , docID : C4String , body : C4Slice , revisionFlags : C4RevisionFlags , error : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_update (doc : * mut C4Document , revisionBody : C4Slice , revisionFlags : C4RevisionFlags , error : * mut C4Error ,) -> * mut C4Document ; }
extern "C" { pub fn c4doc_getProperties (arg1 : * mut C4Document) -> FLDict ; }
extern "C" { pub fn c4doc_createFleeceDoc (arg1 : * mut C4Document) -> FLDoc ; }
extern "C" { pub fn c4doc_resolveConflict2 (doc : * mut C4Document , winningRevID : C4String , losingRevID : C4String , mergedProperties : FLDict , mergedFlags : C4RevisionFlags , error : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4doc_containingValue (value : FLValue) -> * mut C4Document ; }
extern "C" { pub fn c4doc_isOldMetaProperty (prop : C4String) -> bool ; }
extern "C" { pub fn c4doc_hasOldMetaProperties (doc : FLDict) -> bool ; }
extern "C" { pub fn c4doc_encodeStrippingOldMetaProperties (doc : FLDict , sk : FLSharedKeys , outError : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4doc_getDictBlobKey (dict : FLDict , outKey : * mut C4BlobKey) -> bool ; }
extern "C" { pub fn c4doc_dictIsBlob (dict : FLDict , outKey : * mut C4BlobKey) -> bool ; }
extern "C" { pub fn c4doc_dictContainsBlobs (dict : FLDict) -> bool ; }
extern "C" { pub fn c4doc_getBlobData (dict : FLDict , blobStore : * mut C4BlobStore , outError : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4doc_blobIsCompressible (blobDict : FLDict) -> bool ; }
extern "C" { pub fn c4doc_bodyAsJSON (doc : * mut C4Document , canonical : bool , outError : * mut C4Error ,) -> C4StringResult ; }
extern "C" { pub fn c4db_createFleeceEncoder (db : * mut C4Database) -> FLEncoder ; }
extern "C" { pub fn c4db_getSharedFleeceEncoder (db : * mut C4Database) -> FLEncoder ; }
extern "C" { pub fn c4db_encodeJSON (arg1 : * mut C4Database , jsonData : C4String , outError : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4db_getFLSharedKeys (db : * mut C4Database) -> FLSharedKeys ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4EnumeratorFlags(pub u16);
impl C4EnumeratorFlags {
    pub const kC4Descending: C4EnumeratorFlags = C4EnumeratorFlags(1);
    pub const kC4Unsorted: C4EnumeratorFlags = C4EnumeratorFlags(2);
    pub const kC4IncludeDeleted: C4EnumeratorFlags = C4EnumeratorFlags(8);
    pub const kC4IncludeNonConflicted: C4EnumeratorFlags = C4EnumeratorFlags(16);
    pub const kC4IncludeBodies: C4EnumeratorFlags = C4EnumeratorFlags(32);
    pub const kC4IncludeRevHistory: C4EnumeratorFlags = C4EnumeratorFlags(64);
}
impl std::ops::BitAnd for C4EnumeratorFlags {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4EnumeratorFlags {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4EnumeratorOptions { pub flags : C4EnumeratorFlags , }
extern "C" { pub static kC4DefaultEnumeratorOptions : C4EnumeratorOptions ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DocumentInfo { pub flags : C4DocumentFlags , pub docID : C4HeapString , pub revID : C4HeapString , pub sequence : C4SequenceNumber , pub bodySize : u64 , pub metaSize : u64 , pub expiration : C4Timestamp , }
extern "C" { pub fn c4enum_close (e : * mut C4DocEnumerator) ; }
extern "C" { pub fn c4db_enumerateChanges (database : * mut C4Database , since : C4SequenceNumber , options : * const C4EnumeratorOptions , outError : * mut C4Error ,) -> * mut C4DocEnumerator ; }
extern "C" { pub fn c4db_enumerateAllDocs (database : * mut C4Database , options : * const C4EnumeratorOptions , outError : * mut C4Error ,) -> * mut C4DocEnumerator ; }
extern "C" { pub fn c4coll_enumerateChanges (collection : * mut C4Collection , since : C4SequenceNumber , options : * const C4EnumeratorOptions , outError : * mut C4Error ,) -> * mut C4DocEnumerator ; }
extern "C" { pub fn c4coll_enumerateAllDocs (collection : * mut C4Collection , options : * const C4EnumeratorOptions , outError : * mut C4Error ,) -> * mut C4DocEnumerator ; }
extern "C" { pub fn c4enum_next (e : * mut C4DocEnumerator , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4enum_getDocument (e : * mut C4DocEnumerator , outError : * mut C4Error) -> * mut C4Document ; }
extern "C" { pub fn c4enum_getDocumentInfo (e : * mut C4DocEnumerator , outInfo : * mut C4DocumentInfo) -> bool ; }
extern "C" { pub fn c4db_createIndex (database : * mut C4Database , name : C4String , indexSpecJSON : C4String , indexType : C4IndexType , indexOptions : * const C4IndexOptions , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_createIndex2 (database : * mut C4Database , name : C4String , indexSpec : C4String , queryLanguage : C4QueryLanguage , indexType : C4IndexType , indexOptions : * const C4IndexOptions , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_deleteIndex (database : * mut C4Database , name : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_getIndexesInfo (database : * mut C4Database , outError : * mut C4Error) -> C4SliceResult ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ListenerAPIs(pub :: std :: os :: raw :: c_uint);
impl C4ListenerAPIs {
    pub const kC4RESTAPI: C4ListenerAPIs = C4ListenerAPIs(1);
    pub const kC4SyncAPI: C4ListenerAPIs = C4ListenerAPIs(2);
}
impl std::ops::BitAnd for C4ListenerAPIs {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4ListenerAPIs {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4PrivateKeyRepresentation(pub :: std :: os :: raw :: c_uint);
impl C4PrivateKeyRepresentation {
    pub const kC4PrivateKeyFromCert: C4PrivateKeyRepresentation = C4PrivateKeyRepresentation(0);
    pub const kC4PrivateKeyFromKey: C4PrivateKeyRepresentation = C4PrivateKeyRepresentation(1);
}
pub type C4ListenerCertAuthCallback = :: std :: option :: Option < unsafe extern "C" fn (listener : * mut C4Listener , clientCertData : C4Slice , context : * mut :: std :: os :: raw :: c_void ,) -> bool , > ;
pub type C4ListenerHTTPAuthCallback = :: std :: option :: Option < unsafe extern "C" fn (listener : * mut C4Listener , authHeader : C4Slice , context : * mut :: std :: os :: raw :: c_void ,) -> bool , > ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4TLSConfig { pub privateKeyRepresentation : C4PrivateKeyRepresentation , pub key : * mut C4KeyPair , pub certificate : * mut C4Cert , pub requireClientCerts : bool , pub rootClientCerts : * mut C4Cert , pub certAuthCallback : C4ListenerCertAuthCallback , pub tlsCallbackContext : * mut :: std :: os :: raw :: c_void , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ListenerConfig { pub port : u16 , pub networkInterface : C4String , pub apis : C4ListenerAPIs , pub tlsConfig : * mut C4TLSConfig , pub httpAuthCallback : C4ListenerHTTPAuthCallback , pub callbackContext : * mut :: std :: os :: raw :: c_void , pub directory : C4String , pub allowCreateDBs : bool , pub allowDeleteDBs : bool , pub allowCreateCollections : bool , pub allowDeleteCollections : bool , pub allowPush : bool , pub allowPull : bool , pub enableDeltaSync : bool , }
extern "C" { pub fn c4listener_availableAPIs () -> C4ListenerAPIs ; }
extern "C" { pub fn c4listener_start (config : * const C4ListenerConfig , error : * mut C4Error ,) -> * mut C4Listener ; }
extern "C" { pub fn c4listener_shareDB (listener : * mut C4Listener , name : C4String , db : * mut C4Database , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4listener_unshareDB (listener : * mut C4Listener , db : * mut C4Database , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4listener_shareCollection (listener : * mut C4Listener , name : C4String , collection : * mut C4Collection , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4listener_unshareCollection (listener : * mut C4Listener , name : C4String , collection : * mut C4Collection , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4listener_getURLs (listener : * const C4Listener , db : * mut C4Database , api : C4ListenerAPIs , err : * mut C4Error ,) -> FLMutableArray ; }
extern "C" { pub fn c4listener_getPort (listener : * const C4Listener) -> u16 ; }
extern "C" { pub fn c4listener_getConnectionStatus (listener : * const C4Listener , connectionCount : * mut :: std :: os :: raw :: c_uint , activeConnectionCount : * mut :: std :: os :: raw :: c_uint ,) ; }
extern "C" { pub fn c4db_URINameFromPath (path : C4String) -> C4StringResult ; }
pub type C4CollectionObserverCallback = :: std :: option :: Option < unsafe extern "C" fn (observer : * mut C4CollectionObserver , context : * mut :: std :: os :: raw :: c_void) , > ;
extern "C" { pub fn c4dbobs_createOnCollection (collection : * mut C4Collection , callback : C4CollectionObserverCallback , context : * mut :: std :: os :: raw :: c_void , error : * mut C4Error ,) -> * mut C4CollectionObserver ; }
extern "C" { pub fn c4dbobs_getChanges (observer : * mut C4CollectionObserver , outChanges : * mut C4CollectionChange , maxChanges : u32 ,) -> C4CollectionObservation ; }
extern "C" { pub fn c4dbobs_releaseChanges (changes : * mut C4CollectionChange , numChanges : u32) ; }
pub type C4DocumentObserverCallback = :: std :: option :: Option < unsafe extern "C" fn (observer : * mut C4DocumentObserver , collection : * mut C4Collection , docID : C4String , sequence : C4SequenceNumber , context : * mut :: std :: os :: raw :: c_void ,) , > ;
extern "C" { pub fn c4docobs_createWithCollection (collection : * mut C4Collection , docID : C4String , callback : C4DocumentObserverCallback , context : * mut :: std :: os :: raw :: c_void , error : * mut C4Error ,) -> * mut C4DocumentObserver ; }
pub type C4QueryObserverCallback = :: std :: option :: Option < unsafe extern "C" fn (observer : * mut C4QueryObserver , query : * mut C4Query , context : * mut :: std :: os :: raw :: c_void ,) , > ;
extern "C" { pub fn c4queryobs_create (query : * mut C4Query , callback : C4QueryObserverCallback , context : * mut :: std :: os :: raw :: c_void ,) -> * mut C4QueryObserver ; }
extern "C" { pub fn c4queryobs_setEnabled (obs : * mut C4QueryObserver , enabled : bool) ; }
extern "C" { pub fn c4queryobs_getEnumerator (obs : * mut C4QueryObserver , forget : bool , error : * mut C4Error ,) -> * mut C4QueryEnumerator ; }
extern "C" { pub fn c4query_new2 (database : * mut C4Database , language : C4QueryLanguage , expression : C4String , outErrorPos : * mut :: std :: os :: raw :: c_int , error : * mut C4Error ,) -> * mut C4Query ; }
extern "C" { pub fn c4query_explain (arg1 : * mut C4Query) -> C4StringResult ; }
extern "C" { pub fn c4query_columnCount (arg1 : * mut C4Query) -> :: std :: os :: raw :: c_uint ; }
extern "C" { pub fn c4query_columnTitle (arg1 : * mut C4Query , column : :: std :: os :: raw :: c_uint) -> FLString ; }
extern "C" { pub fn c4query_setParameters (query : * mut C4Query , encodedParameters : C4String) ; }
extern "C" { pub fn c4query_run (query : * mut C4Query , options : * const C4QueryOptions , encodedParameters : C4String , outError : * mut C4Error ,) -> * mut C4QueryEnumerator ; }
extern "C" { pub fn c4query_fullTextMatched (query : * mut C4Query , term : * const C4FullTextMatch , outError : * mut C4Error ,) -> C4StringResult ; }
extern "C" { pub fn c4queryenum_next (e : * mut C4QueryEnumerator , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4queryenum_getRowCount (e : * mut C4QueryEnumerator , outError : * mut C4Error) -> i64 ; }
extern "C" { pub fn c4queryenum_seek (e : * mut C4QueryEnumerator , rowIndex : i64 , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4queryenum_refresh (e : * mut C4QueryEnumerator , outError : * mut C4Error ,) -> * mut C4QueryEnumerator ; }
extern "C" { pub fn c4queryenum_close (arg1 : * mut C4QueryEnumerator) ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ReplicatorMode(pub i32);
impl C4ReplicatorMode {
    pub const kC4Disabled: C4ReplicatorMode = C4ReplicatorMode(0);
    pub const kC4Passive: C4ReplicatorMode = C4ReplicatorMode(1);
    pub const kC4OneShot: C4ReplicatorMode = C4ReplicatorMode(2);
    pub const kC4Continuous: C4ReplicatorMode = C4ReplicatorMode(3);
}

    #[repr(i32)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum C4ReplicatorActivityLevel {
    kC4Stopped = 0,
    kC4Offline = 1,
    kC4Connecting = 2,
    kC4Idle = 3,
    kC4Busy = 4,
    kC4Stopping = 5,
}
extern "C" { pub static kC4ReplicatorActivityLevelNames : [* const :: std :: os :: raw :: c_char ; 6usize] ; }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Address { pub scheme : C4String , pub hostname : C4String , pub port : u16 , pub path : C4String , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4Progress { pub unitsCompleted : u64 , pub unitsTotal : u64 , pub documentCount : u64 , }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ReplicatorStatusFlags(pub i32);
impl C4ReplicatorStatusFlags {
    pub const kC4WillRetry: C4ReplicatorStatusFlags = C4ReplicatorStatusFlags(1);
    pub const kC4HostReachable: C4ReplicatorStatusFlags = C4ReplicatorStatusFlags(2);
    pub const kC4Suspended: C4ReplicatorStatusFlags = C4ReplicatorStatusFlags(4);
}
impl std::ops::BitAnd for C4ReplicatorStatusFlags {
        type Output = Self;
        #[doc = " Returns the intersection between the two sets of flags."]
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    }

    impl std::ops::BitOr for C4ReplicatorStatusFlags {
        type Output = Self;
        #[doc = " Returns the union of the two sets of flags."]
        #[inline]
        fn bitor(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4ReplicatorProgressLevel(pub i32);
impl C4ReplicatorProgressLevel {
    pub const kC4ReplProgressOverall: C4ReplicatorProgressLevel = C4ReplicatorProgressLevel(0);
    pub const kC4ReplProgressPerDocument: C4ReplicatorProgressLevel = C4ReplicatorProgressLevel(1);
    pub const kC4ReplProgressPerAttachment: C4ReplicatorProgressLevel = C4ReplicatorProgressLevel(2);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ReplicatorStatus { pub level : C4ReplicatorActivityLevel , pub progress : C4Progress , pub error : C4Error , pub flags : C4ReplicatorStatusFlags , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4DocumentEnded { pub collectionSpec : C4CollectionSpec , pub docID : C4HeapString , pub revID : C4HeapString , pub flags : C4RevisionFlags , pub sequence : C4SequenceNumber , pub error : C4Error , pub errorIsTransient : bool , pub collectionContext : * mut :: std :: os :: raw :: c_void , }
pub type C4ReplicatorStatusChangedCallback = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut C4Replicator , arg2 : C4ReplicatorStatus , context : * mut :: std :: os :: raw :: c_void ,) , > ;
pub type C4ReplicatorDocumentsEndedCallback = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut C4Replicator , pushing : bool , numDocs : usize , docs : * mut * const C4DocumentEnded , context : * mut :: std :: os :: raw :: c_void ,) , > ;
pub type C4ReplicatorBlobProgressCallback = :: std :: option :: Option < unsafe extern "C" fn (arg1 : * mut C4Replicator , pushing : bool , collectionSpec : C4CollectionSpec , docID : C4String , docProperty : C4String , blobKey : C4BlobKey , bytesComplete : u64 , bytesTotal : u64 , error : C4Error , context : * mut :: std :: os :: raw :: c_void ,) , > ;
pub type C4ReplicatorValidationFunction = :: std :: option :: Option < unsafe extern "C" fn (collectionSpec : C4CollectionSpec , docID : C4String , revID : C4String , arg1 : C4RevisionFlags , body : FLDict , context : * mut :: std :: os :: raw :: c_void ,) -> bool , > ;
pub type C4ReplicatorPropertyEncryptionCallback = * mut :: std :: os :: raw :: c_void ;
pub type C4ReplicatorPropertyDecryptionCallback = * mut :: std :: os :: raw :: c_void ;
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ReplicationCollection { pub collection : C4CollectionSpec , pub push : C4ReplicatorMode , pub pull : C4ReplicatorMode , pub optionsDictFleece : C4Slice , pub pushFilter : C4ReplicatorValidationFunction , pub pullFilter : C4ReplicatorValidationFunction , pub callbackContext : * mut :: std :: os :: raw :: c_void , }
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4ReplicatorParameters { pub optionsDictFleece : C4Slice , pub onStatusChanged : C4ReplicatorStatusChangedCallback , pub onDocumentsEnded : C4ReplicatorDocumentsEndedCallback , pub onBlobProgress : C4ReplicatorBlobProgressCallback , pub propertyEncryptor : C4ReplicatorPropertyEncryptionCallback , pub propertyDecryptor : C4ReplicatorPropertyDecryptionCallback , pub callbackContext : * mut :: std :: os :: raw :: c_void , pub socketFactory : * const C4SocketFactory , pub collections : * mut C4ReplicationCollection , pub collectionCount : usize , }
extern "C" { pub fn c4repl_isValidDatabaseName (dbName : C4String) -> bool ; }
extern "C" { pub fn c4repl_isValidRemote (remoteAddress : C4Address , remoteDatabaseName : C4String , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4address_fromURL (url : C4String , address : * mut C4Address , dbName : * mut C4String) -> bool ; }
extern "C" { pub fn c4address_toURL (address : C4Address) -> C4StringResult ; }
extern "C" { pub fn c4repl_new (db : * mut C4Database , remoteAddress : C4Address , remoteDatabaseName : C4String , params : C4ReplicatorParameters , outError : * mut C4Error ,) -> * mut C4Replicator ; }
extern "C" { pub fn c4repl_newWithSocket (db : * mut C4Database , openSocket : * mut C4Socket , params : C4ReplicatorParameters , outError : * mut C4Error ,) -> * mut C4Replicator ; }
extern "C" { pub fn c4repl_start (repl : * mut C4Replicator , reset : bool) ; }
extern "C" { pub fn c4repl_stop (repl : * mut C4Replicator) ; }
extern "C" { pub fn c4repl_retry (repl : * mut C4Replicator , outError : * mut C4Error) -> bool ; }
extern "C" { pub fn c4repl_setHostReachable (repl : * mut C4Replicator , reachable : bool) ; }
extern "C" { pub fn c4repl_setSuspended (repl : * mut C4Replicator , suspended : bool) ; }
extern "C" { pub fn c4repl_setOptions (repl : * mut C4Replicator , optionsDictFleece : C4Slice) ; }
extern "C" { pub fn c4repl_getStatus (repl : * mut C4Replicator) -> C4ReplicatorStatus ; }
extern "C" { pub fn c4repl_getResponseHeaders (repl : * mut C4Replicator) -> C4Slice ; }
extern "C" { pub fn c4repl_getPendingDocIDs (repl : * mut C4Replicator , spec : C4CollectionSpec , outErr : * mut C4Error ,) -> C4SliceResult ; }
extern "C" { pub fn c4repl_isDocumentPending (repl : * mut C4Replicator , docID : C4String , spec : C4CollectionSpec , outErr : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4repl_getPeerTLSCertificate (repl : * mut C4Replicator , outErr : * mut C4Error ,) -> * mut C4Cert ; }
extern "C" { pub fn c4repl_setProgressLevel (repl : * mut C4Replicator , level : C4ReplicatorProgressLevel , outErr : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_setCookie (db : * mut C4Database , setCookieHeader : C4String , fromHost : C4String , fromPath : C4String , acceptParentDomain : bool , outError : * mut C4Error ,) -> bool ; }
extern "C" { pub fn c4db_getCookies (db : * mut C4Database , request : C4Address , error : * mut C4Error ,) -> C4StringResult ; }
extern "C" { pub fn c4db_clearCookies (db : * mut C4Database) ; }

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4WebSocketCloseCode(pub i32);
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseNormal: C4WebSocketCloseCode = C4WebSocketCloseCode(1000);
    pub const kWebSocketCloseGoingAway: C4WebSocketCloseCode = C4WebSocketCloseCode(1001);
    pub const kWebSocketCloseProtocolError: C4WebSocketCloseCode = C4WebSocketCloseCode(1002);
    pub const kWebSocketCloseDataError: C4WebSocketCloseCode = C4WebSocketCloseCode(1003);
    pub const kWebSocketCloseNoCode: C4WebSocketCloseCode = C4WebSocketCloseCode(1005);
    pub const kWebSocketCloseAbnormal: C4WebSocketCloseCode = C4WebSocketCloseCode(1006);
    pub const kWebSocketCloseBadMessageFormat: C4WebSocketCloseCode = C4WebSocketCloseCode(1007);
    pub const kWebSocketClosePolicyError: C4WebSocketCloseCode = C4WebSocketCloseCode(1008);
    pub const kWebSocketCloseMessageTooBig: C4WebSocketCloseCode = C4WebSocketCloseCode(1009);
    pub const kWebSocketCloseMissingExtension: C4WebSocketCloseCode = C4WebSocketCloseCode(1010);
    pub const kWebSocketCloseCantFulfill: C4WebSocketCloseCode = C4WebSocketCloseCode(1011);
    pub const kWebSocketCloseTLSFailure: C4WebSocketCloseCode = C4WebSocketCloseCode(1015);
    pub const kWebSocketCloseAppTransient: C4WebSocketCloseCode = C4WebSocketCloseCode(4001);
    pub const kWebSocketCloseAppPermanent: C4WebSocketCloseCode = C4WebSocketCloseCode(4002);
    pub const kWebSocketCloseFirstAvailable: C4WebSocketCloseCode = C4WebSocketCloseCode(5000);
}

    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct C4SocketFraming(pub u8);
impl C4SocketFraming {
    pub const kC4WebSocketClientFraming: C4SocketFraming = C4SocketFraming(0);
    pub const kC4NoFraming: C4SocketFraming = C4SocketFraming(1);
    pub const kC4WebSocketServerFraming: C4SocketFraming = C4SocketFraming(2);
}
# [repr (C)] # [derive (Debug , Copy , Clone)] pub struct C4SocketFactory { pub framing : C4SocketFraming , pub context : * mut :: std :: os :: raw :: c_void , pub open : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket , addr : * const C4Address , options : C4Slice , context : * mut :: std :: os :: raw :: c_void ,) , > , pub write : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket , allocatedData : C4SliceResult) , > , pub completedReceive : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket , byteCount : usize) > , pub close : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket) > , pub requestClose : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket , status : :: std :: os :: raw :: c_int , message : C4String ,) , > , pub dispose : :: std :: option :: Option < unsafe extern "C" fn (socket : * mut C4Socket) > , }
extern "C" { pub fn c4socket_registerFactory (factory : C4SocketFactory) ; }
extern "C" { pub fn c4Socket_setNativeHandle (arg1 : * mut C4Socket , arg2 : * mut :: std :: os :: raw :: c_void) ; }
extern "C" { pub fn c4Socket_getNativeHandle (arg1 : * mut C4Socket) -> * mut :: std :: os :: raw :: c_void ; }
extern "C" { pub fn c4socket_gotHTTPResponse (socket : * mut C4Socket , httpStatus : :: std :: os :: raw :: c_int , responseHeadersFleece : C4Slice ,) ; }
extern "C" { pub fn c4socket_opened (socket : * mut C4Socket) ; }
extern "C" { pub fn c4socket_closed (socket : * mut C4Socket , errorIfAny : C4Error) ; }
extern "C" { pub fn c4socket_closeRequested (socket : * mut C4Socket , status : :: std :: os :: raw :: c_int , message : C4String ,) ; }
extern "C" { pub fn c4socket_completedWrite (socket : * mut C4Socket , byteCount : usize) ; }
extern "C" { pub fn c4socket_received (socket : * mut C4Socket , data : C4Slice) ; }
extern "C" { pub fn c4socket_fromNative (factory : C4SocketFactory , nativeHandle : * mut :: std :: os :: raw :: c_void , address : * const C4Address ,) -> * mut C4Socket ; }
pub type __builtin_va_list = * mut :: std :: os :: raw :: c_char ;
