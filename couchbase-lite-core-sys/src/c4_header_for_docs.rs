/* automatically generated by rust-bindgen 0.59.2 */

pub const kC4GeneratedIDLength: u32 = 23;
pub const kC4ObjectTypeProperty: &[u8; 6usize] = b"@type\0";
pub const kC4ObjectType_Blob: &[u8; 5usize] = b"blob\0";
pub const kC4BlobDigestProperty: &[u8; 7usize] = b"digest\0";
pub const kC4BlobDataProperty: &[u8; 5usize] = b"data\0";
pub const kC4LegacyAttachmentsProperty: &[u8; 13usize] = b"_attachments\0";
pub const kC4ObjectType_Encryptable: &[u8; 12usize] = b"encryptable\0";
pub const kC4EncryptableValueProperty: &[u8; 6usize] = b"value\0";
pub const kC4ReplicatorOptionDocIDs: &[u8; 7usize] = b"docIDs\0";
pub const kC4ReplicatorOptionChannels: &[u8; 9usize] = b"channels\0";
pub const kC4ReplicatorOptionFilter: &[u8; 7usize] = b"filter\0";
pub const kC4ReplicatorOptionFilterParams: &[u8; 13usize] = b"filterParams\0";
pub const kC4ReplicatorOptionSkipDeleted: &[u8; 12usize] = b"skipDeleted\0";
pub const kC4ReplicatorOptionNoIncomingConflicts: &[u8; 20usize] = b"noIncomingConflicts\0";
pub const kC4ReplicatorCheckpointInterval: &[u8; 19usize] = b"checkpointInterval\0";
pub const kC4ReplicatorOptionRemoteDBUniqueID: &[u8; 17usize] = b"remoteDBUniqueID\0";
pub const kC4ReplicatorOptionDisableDeltas: &[u8; 9usize] = b"noDeltas\0";
pub const kC4ReplicatorOptionDisablePropertyDecryption: &[u8; 13usize] = b"noDecryption\0";
pub const kC4ReplicatorOptionMaxRetries: &[u8; 11usize] = b"maxRetries\0";
pub const kC4ReplicatorOptionMaxRetryInterval: &[u8; 17usize] = b"maxRetryInterval\0";
pub const kC4ReplicatorOptionAutoPurge: &[u8; 10usize] = b"autoPurge\0";
pub const kC4ReplicatorOptionRootCerts: &[u8; 10usize] = b"rootCerts\0";
pub const kC4ReplicatorOptionPinnedServerCert: &[u8; 11usize] = b"pinnedCert\0";
pub const kC4ReplicatorOptionOnlySelfSignedServerCert: &[u8; 21usize] = b"onlySelfSignedServer\0";
pub const kC4ReplicatorOptionExtraHeaders: &[u8; 8usize] = b"headers\0";
pub const kC4ReplicatorOptionCookies: &[u8; 8usize] = b"cookies\0";
pub const kC4ReplicatorOptionAuthentication: &[u8; 5usize] = b"auth\0";
pub const kC4ReplicatorOptionProxyServer: &[u8; 6usize] = b"proxy\0";
pub const kC4ReplicatorHeartbeatInterval: &[u8; 10usize] = b"heartbeat\0";
pub const kC4SocketOptionWSProtocols: &[u8; 13usize] = b"WS-Protocols\0";
pub const kC4ReplicatorCompressionLevel: &[u8; 21usize] = b"BLIPCompressionLevel\0";
pub const kC4ReplicatorAuthType: &[u8; 5usize] = b"type\0";
pub const kC4ReplicatorAuthUserName: &[u8; 9usize] = b"username\0";
pub const kC4ReplicatorAuthPassword: &[u8; 9usize] = b"password\0";
pub const kC4ReplicatorAuthClientCert: &[u8; 11usize] = b"clientCert\0";
pub const kC4ReplicatorAuthClientCertKey: &[u8; 14usize] = b"clientCertKey\0";
pub const kC4ReplicatorAuthToken: &[u8; 6usize] = b"token\0";
pub const kC4AuthTypeBasic: &[u8; 6usize] = b"Basic\0";
pub const kC4AuthTypeSession: &[u8; 8usize] = b"Session\0";
pub const kC4AuthTypeOpenIDConnect: &[u8; 15usize] = b"OpenID Connect\0";
pub const kC4AuthTypeFacebook: &[u8; 9usize] = b"Facebook\0";
pub const kC4AuthTypeClientCert: &[u8; 12usize] = b"Client Cert\0";
pub const kC4ReplicatorProxyType: &[u8; 5usize] = b"type\0";
pub const kC4ReplicatorProxyHost: &[u8; 5usize] = b"host\0";
pub const kC4ReplicatorProxyPort: &[u8; 5usize] = b"port\0";
pub const kC4ReplicatorProxyAuth: &[u8; 5usize] = b"auth\0";
pub const kC4ProxyTypeNone: &[u8; 5usize] = b"none\0";
pub const kC4ProxyTypeHTTP: &[u8; 5usize] = b"HTTP\0";
pub const kC4ProxyTypeHTTPS: &[u8; 6usize] = b"HTTPS\0";
pub const kC4ProxyTypeSOCKS: &[u8; 6usize] = b"SOCKS\0";
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type std_string = [u64; 4usize];
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std___bool_constant = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___not_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_same {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_remove_cv {
    pub _address: u8,
}
pub type std_remove_cv_type<_Tp> = _Tp;
pub type std___remove_cvref_t = std_remove_cv;
pub type std_enable_if_t = u8;
#[repr(C)]
pub struct std_exception__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_exception {
    pub vtable_: *const std_exception__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_in_place_t {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional__Base = u8;
pub type std_optional___not_self = std___not_;
pub type std_optional___not_tag = std___not_;
pub type std_optional__Requires = std_enable_if_t;
pub type std_optional_value_type<_Tp> = _Tp;
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
pub type va_list = __gnuc_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fleece_pure_slice {
    pub buf: *const ::std::os::raw::c_void,
    pub size: usize,
}
extern "C" {
    #[link_name = "\u{1}_ZNK6fleece10pure_slice6offsetEm"]
    pub fn fleece_pure_slice_offset(
        this: *const fleece_pure_slice,
        o: usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6fleece10pure_slice8offsetOfEPKv"]
    pub fn fleece_pure_slice_offsetOf(
        this: *const fleece_pure_slice,
        ptr: *const ::std::os::raw::c_void,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNK6fleece10pure_slice9hexStringB5cxx11Ev"]
    pub fn fleece_pure_slice_hexString(this: *const fleece_pure_slice) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN6fleece10pure_slice12failBadAllocEv"]
    pub fn fleece_pure_slice_failBadAlloc();
}
impl fleece_pure_slice {
    #[inline]
    pub unsafe fn offset(&self, o: usize) -> *const ::std::os::raw::c_void {
        fleece_pure_slice_offset(self, o)
    }
    #[inline]
    pub unsafe fn offsetOf(&self, ptr: *const ::std::os::raw::c_void) -> usize {
        fleece_pure_slice_offsetOf(self, ptr)
    }
    #[inline]
    pub unsafe fn hexString(&self) -> std_string {
        fleece_pure_slice_hexString(self)
    }
    #[inline]
    pub unsafe fn failBadAlloc() {
        fleece_pure_slice_failBadAlloc()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fleece_slice {
    pub _base: fleece_pure_slice,
}
#[repr(C)]
#[derive(Debug)]
pub struct fleece_alloc_slice {
    pub _base: fleece_pure_slice,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLSlice {
    pub buf: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[repr(C)]
#[derive(Debug)]
pub struct FLSliceResult {
    pub buf: *const ::std::os::raw::c_void,
    pub size: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLHeapSlice {
    pub _base: FLSlice,
}
pub type FLString = FLSlice;
pub type FLStringResult = FLSliceResult;
extern "C" {
    pub fn FLSlice_Equal(a: FLSlice, b: FLSlice) -> bool;
}
extern "C" {
    pub fn FLSlice_Compare(arg1: FLSlice, arg2: FLSlice) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FLSlice_Hash(s: FLSlice) -> u32;
}
extern "C" {
    pub fn FLSlice_ToCString(
        s: FLSlice,
        buffer: *mut ::std::os::raw::c_char,
        capacity: usize,
    ) -> bool;
}
extern "C" {
    pub fn FLSliceResult_New(arg1: usize) -> FLSliceResult;
}
extern "C" {
    pub fn FLSlice_Copy(arg1: FLSlice) -> FLSliceResult;
}
extern "C" {
    pub fn _FLBuf_Retain(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _FLBuf_Release(arg1: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn FL_WipeMemory(dst: *mut ::std::os::raw::c_void, size: usize);
}
impl C4ErrorDomain {
    pub const LiteCoreDomain: C4ErrorDomain = C4ErrorDomain(1);
}
impl C4ErrorDomain {
    pub const POSIXDomain: C4ErrorDomain = C4ErrorDomain(2);
}
impl C4ErrorDomain {
    pub const SQLiteDomain: C4ErrorDomain = C4ErrorDomain(3);
}
impl C4ErrorDomain {
    pub const FleeceDomain: C4ErrorDomain = C4ErrorDomain(4);
}
impl C4ErrorDomain {
    pub const NetworkDomain: C4ErrorDomain = C4ErrorDomain(5);
}
impl C4ErrorDomain {
    pub const WebSocketDomain: C4ErrorDomain = C4ErrorDomain(6);
}
impl C4ErrorDomain {
    pub const MbedTLSDomain: C4ErrorDomain = C4ErrorDomain(7);
}
impl C4ErrorDomain {
    pub const kC4MaxErrorDomainPlus1: C4ErrorDomain = C4ErrorDomain(8);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4ErrorDomain(pub u8);
impl C4ErrorCode {
    pub const kC4ErrorAssertionFailed: C4ErrorCode = C4ErrorCode(1);
}
impl C4ErrorCode {
    pub const kC4ErrorUnimplemented: C4ErrorCode = C4ErrorCode(2);
}
impl C4ErrorCode {
    pub const kC4ErrorUnsupportedEncryption: C4ErrorCode = C4ErrorCode(3);
}
impl C4ErrorCode {
    pub const kC4ErrorBadRevisionID: C4ErrorCode = C4ErrorCode(4);
}
impl C4ErrorCode {
    pub const kC4ErrorCorruptRevisionData: C4ErrorCode = C4ErrorCode(5);
}
impl C4ErrorCode {
    pub const kC4ErrorNotOpen: C4ErrorCode = C4ErrorCode(6);
}
impl C4ErrorCode {
    pub const kC4ErrorNotFound: C4ErrorCode = C4ErrorCode(7);
}
impl C4ErrorCode {
    pub const kC4ErrorConflict: C4ErrorCode = C4ErrorCode(8);
}
impl C4ErrorCode {
    pub const kC4ErrorInvalidParameter: C4ErrorCode = C4ErrorCode(9);
}
impl C4ErrorCode {
    pub const kC4ErrorUnexpectedError: C4ErrorCode = C4ErrorCode(10);
}
impl C4ErrorCode {
    pub const kC4ErrorCantOpenFile: C4ErrorCode = C4ErrorCode(11);
}
impl C4ErrorCode {
    pub const kC4ErrorIOError: C4ErrorCode = C4ErrorCode(12);
}
impl C4ErrorCode {
    pub const kC4ErrorMemoryError: C4ErrorCode = C4ErrorCode(13);
}
impl C4ErrorCode {
    pub const kC4ErrorNotWriteable: C4ErrorCode = C4ErrorCode(14);
}
impl C4ErrorCode {
    pub const kC4ErrorCorruptData: C4ErrorCode = C4ErrorCode(15);
}
impl C4ErrorCode {
    pub const kC4ErrorBusy: C4ErrorCode = C4ErrorCode(16);
}
impl C4ErrorCode {
    pub const kC4ErrorNotInTransaction: C4ErrorCode = C4ErrorCode(17);
}
impl C4ErrorCode {
    pub const kC4ErrorTransactionNotClosed: C4ErrorCode = C4ErrorCode(18);
}
impl C4ErrorCode {
    pub const kC4ErrorUnsupported: C4ErrorCode = C4ErrorCode(19);
}
impl C4ErrorCode {
    pub const kC4ErrorNotADatabaseFile: C4ErrorCode = C4ErrorCode(20);
}
impl C4ErrorCode {
    pub const kC4ErrorWrongFormat: C4ErrorCode = C4ErrorCode(21);
}
impl C4ErrorCode {
    pub const kC4ErrorCrypto: C4ErrorCode = C4ErrorCode(22);
}
impl C4ErrorCode {
    pub const kC4ErrorInvalidQuery: C4ErrorCode = C4ErrorCode(23);
}
impl C4ErrorCode {
    pub const kC4ErrorMissingIndex: C4ErrorCode = C4ErrorCode(24);
}
impl C4ErrorCode {
    pub const kC4ErrorInvalidQueryParam: C4ErrorCode = C4ErrorCode(25);
}
impl C4ErrorCode {
    pub const kC4ErrorRemoteError: C4ErrorCode = C4ErrorCode(26);
}
impl C4ErrorCode {
    pub const kC4ErrorDatabaseTooOld: C4ErrorCode = C4ErrorCode(27);
}
impl C4ErrorCode {
    pub const kC4ErrorDatabaseTooNew: C4ErrorCode = C4ErrorCode(28);
}
impl C4ErrorCode {
    pub const kC4ErrorBadDocID: C4ErrorCode = C4ErrorCode(29);
}
impl C4ErrorCode {
    pub const kC4ErrorCantUpgradeDatabase: C4ErrorCode = C4ErrorCode(30);
}
impl C4ErrorCode {
    pub const kC4ErrorDeltaBaseUnknown: C4ErrorCode = C4ErrorCode(31);
}
impl C4ErrorCode {
    pub const kC4ErrorCorruptDelta: C4ErrorCode = C4ErrorCode(32);
}
impl C4ErrorCode {
    pub const kC4NumErrorCodesPlus1: C4ErrorCode = C4ErrorCode(33);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4ErrorCode(pub i32);
impl C4NetworkErrorCode {
    pub const kC4NetErrDNSFailure: C4NetworkErrorCode = C4NetworkErrorCode(1);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrUnknownHost: C4NetworkErrorCode = C4NetworkErrorCode(2);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTimeout: C4NetworkErrorCode = C4NetworkErrorCode(3);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrInvalidURL: C4NetworkErrorCode = C4NetworkErrorCode(4);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTooManyRedirects: C4NetworkErrorCode = C4NetworkErrorCode(5);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSHandshakeFailed: C4NetworkErrorCode = C4NetworkErrorCode(6);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertExpired: C4NetworkErrorCode = C4NetworkErrorCode(7);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertUntrusted: C4NetworkErrorCode = C4NetworkErrorCode(8);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertRequiredByPeer: C4NetworkErrorCode = C4NetworkErrorCode(9);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertRejectedByPeer: C4NetworkErrorCode = C4NetworkErrorCode(10);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertUnknownRoot: C4NetworkErrorCode = C4NetworkErrorCode(11);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrInvalidRedirect: C4NetworkErrorCode = C4NetworkErrorCode(12);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrUnknown: C4NetworkErrorCode = C4NetworkErrorCode(13);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertRevoked: C4NetworkErrorCode = C4NetworkErrorCode(14);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrTLSCertNameMismatch: C4NetworkErrorCode = C4NetworkErrorCode(15);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrNetworkReset: C4NetworkErrorCode = C4NetworkErrorCode(16);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrConnectionAborted: C4NetworkErrorCode = C4NetworkErrorCode(17);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrConnectionReset: C4NetworkErrorCode = C4NetworkErrorCode(18);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrConnectionRefused: C4NetworkErrorCode = C4NetworkErrorCode(19);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrNetworkDown: C4NetworkErrorCode = C4NetworkErrorCode(20);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrNetworkUnreachable: C4NetworkErrorCode = C4NetworkErrorCode(21);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrNotConnected: C4NetworkErrorCode = C4NetworkErrorCode(22);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrHostDown: C4NetworkErrorCode = C4NetworkErrorCode(23);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrHostUnreachable: C4NetworkErrorCode = C4NetworkErrorCode(24);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrAddressNotAvailable: C4NetworkErrorCode = C4NetworkErrorCode(25);
}
impl C4NetworkErrorCode {
    pub const kC4NetErrBrokenPipe: C4NetworkErrorCode = C4NetworkErrorCode(26);
}
impl C4NetworkErrorCode {
    pub const kC4NumNetErrorCodesPlus1: C4NetworkErrorCode = C4NetworkErrorCode(27);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4NetworkErrorCode(pub i32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Error {
    pub domain: C4ErrorDomain,
    pub code: ::std::os::raw::c_int,
    pub internal_info: ::std::os::raw::c_uint,
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error4makeE13C4ErrorDomainiN6fleece5sliceE"]
    pub fn C4Error_make(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        message: fleece_slice,
    ) -> C4Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error6printfE13C4ErrorDomainiPKcz"]
    pub fn C4Error_printf(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> C4Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error7vprintfE13C4ErrorDomainiPKcP13__va_list_tag"]
    pub fn C4Error_vprintf(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> C4Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error3setEPS_13C4ErrorDomainiPKcz"]
    pub fn C4Error_set(
        arg1: *mut C4Error,
        arg2: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error13fromExceptionERKSt9exception"]
    pub fn C4Error_fromException(e: *const std_exception) -> C4Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error20fromCurrentExceptionEv"]
    pub fn C4Error_fromCurrentException() -> C4Error;
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error20warnCurrentExceptionEPKc"]
    pub fn C4Error_warnCurrentException(inFunction: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error5raiseE13C4ErrorDomainiPKcz"]
    pub fn C4Error_raise(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error20setCaptureBacktracesEb"]
    pub fn C4Error_setCaptureBacktraces(arg1: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7C4Error20getCaptureBacktracesEv"]
    pub fn C4Error_getCaptureBacktraces() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error5raiseEv"]
    pub fn C4Error_raise1(this: *const C4Error);
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error7messageB5cxx11Ev"]
    pub fn C4Error_message(this: *const C4Error) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error11descriptionB5cxx11Ev"]
    pub fn C4Error_description(this: *const C4Error) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error9backtraceB5cxx11Ev"]
    pub fn C4Error_backtrace(this: *const C4Error) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error14mayBeTransientEv"]
    pub fn C4Error_mayBeTransient(this: *const C4Error) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK7C4Error21mayBeNetworkDependentEv"]
    pub fn C4Error_mayBeNetworkDependent(this: *const C4Error) -> bool;
}
impl C4Error {
    #[inline]
    pub unsafe fn make(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        message: fleece_slice,
    ) -> C4Error {
        C4Error_make(arg1, code, message)
    }
    #[inline]
    pub unsafe fn vprintf(
        arg1: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> C4Error {
        C4Error_vprintf(arg1, code, format, args)
    }
    #[inline]
    pub unsafe fn fromException(e: *const std_exception) -> C4Error {
        C4Error_fromException(e)
    }
    #[inline]
    pub unsafe fn fromCurrentException() -> C4Error {
        C4Error_fromCurrentException()
    }
    #[inline]
    pub unsafe fn warnCurrentException(inFunction: *const ::std::os::raw::c_char) {
        C4Error_warnCurrentException(inFunction)
    }
    #[inline]
    pub unsafe fn setCaptureBacktraces(arg1: bool) {
        C4Error_setCaptureBacktraces(arg1)
    }
    #[inline]
    pub unsafe fn getCaptureBacktraces() -> bool {
        C4Error_getCaptureBacktraces()
    }
    #[inline]
    pub unsafe fn raise(&self) {
        C4Error_raise1(self)
    }
    #[inline]
    pub unsafe fn message(&self) -> std_string {
        C4Error_message(self)
    }
    #[inline]
    pub unsafe fn description(&self) -> std_string {
        C4Error_description(self)
    }
    #[inline]
    pub unsafe fn backtrace(&self) -> std_string {
        C4Error_backtrace(self)
    }
    #[inline]
    pub unsafe fn mayBeTransient(&self) -> bool {
        C4Error_mayBeTransient(self)
    }
    #[inline]
    pub unsafe fn mayBeNetworkDependent(&self) -> bool {
        C4Error_mayBeNetworkDependent(self)
    }
}
extern "C" {
    pub fn c4error_getMessage(error: C4Error) -> FLStringResult;
}
extern "C" {
    pub fn c4error_getDescription(error: C4Error) -> FLSliceResult;
}
extern "C" {
    pub fn c4error_getDescriptionC(
        error: C4Error,
        outBuffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn c4error_setCaptureBacktraces(arg1: bool);
}
extern "C" {
    pub fn c4error_getCaptureBacktraces() -> bool;
}
extern "C" {
    pub fn c4error_getBacktrace(error: C4Error) -> FLStringResult;
}
extern "C" {
    pub fn c4error_make(
        domain: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        message: FLString,
    ) -> C4Error;
}
extern "C" {
    pub fn c4error_printf(
        domain: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> C4Error;
}
extern "C" {
    pub fn c4error_vprintf(
        domain: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> C4Error;
}
extern "C" {
    pub fn c4error_return(
        domain: C4ErrorDomain,
        code: ::std::os::raw::c_int,
        message: FLString,
        outError: *mut C4Error,
    );
}
extern "C" {
    pub fn c4error_mayBeTransient(err: C4Error) -> bool;
}
extern "C" {
    pub fn c4error_mayBeNetworkDependent(err: C4Error) -> bool;
}
impl C4LogLevel {
    pub const kC4LogDebug: C4LogLevel = C4LogLevel(0);
}
impl C4LogLevel {
    pub const kC4LogVerbose: C4LogLevel = C4LogLevel(1);
}
impl C4LogLevel {
    pub const kC4LogInfo: C4LogLevel = C4LogLevel(2);
}
impl C4LogLevel {
    pub const kC4LogWarning: C4LogLevel = C4LogLevel(3);
}
impl C4LogLevel {
    pub const kC4LogError: C4LogLevel = C4LogLevel(4);
}
impl C4LogLevel {
    pub const kC4LogNone: C4LogLevel = C4LogLevel(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4LogLevel(pub i8);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct c4LogDomain {
    _unused: [u8; 0],
}
pub type C4LogDomain = *mut c4LogDomain;
extern "C" {
    pub static kC4DefaultLog: C4LogDomain;
}
extern "C" {
    pub static mut kC4DatabaseLog: C4LogDomain;
}
extern "C" {
    pub static mut kC4QueryLog: C4LogDomain;
}
extern "C" {
    pub static mut kC4SyncLog: C4LogDomain;
}
extern "C" {
    pub static mut kC4WebSocketLog: C4LogDomain;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4LogFileOptions {
    pub log_level: C4LogLevel,
    pub base_path: FLString,
    pub max_size_bytes: i64,
    pub max_rotate_count: i32,
    pub use_plaintext: bool,
    pub header: FLString,
}
extern "C" {
    pub fn c4log_writeToBinaryFile(options: C4LogFileOptions, error: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4log_binaryFilePath() -> FLStringResult;
}
extern "C" {
    pub fn c4log_flushLogFiles();
}
extern "C" {
    pub fn c4log_binaryFileLevel() -> C4LogLevel;
}
extern "C" {
    pub fn c4log_setBinaryFileLevel(level: C4LogLevel);
}
extern "C" {
    pub fn c4log_writeToCallback(
        level: C4LogLevel,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: C4LogDomain,
                arg2: C4LogLevel,
                arg3: *const ::std::os::raw::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
        preformatted: bool,
    );
}
extern "C" {
    pub fn c4log_getCallback() -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: C4LogDomain,
            arg2: C4LogLevel,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut __va_list_tag,
        ),
    >;
}
extern "C" {
    pub fn c4log_callbackLevel() -> C4LogLevel;
}
extern "C" {
    pub fn c4log_setCallbackLevel(level: C4LogLevel);
}
extern "C" {
    pub fn c4log_getDomain(name: *const ::std::os::raw::c_char, create: bool) -> C4LogDomain;
}
extern "C" {
    pub fn c4log_getDomainName(arg1: C4LogDomain) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn c4log_getLevel(arg1: C4LogDomain) -> C4LogLevel;
}
extern "C" {
    pub fn c4log_willLog(arg1: C4LogDomain, arg2: C4LogLevel) -> bool;
}
extern "C" {
    pub fn c4log_setLevel(c4Domain: C4LogDomain, level: C4LogLevel);
}
extern "C" {
    pub fn c4log_warnOnErrors(arg1: bool);
}
extern "C" {
    pub fn c4log_getWarnOnErrors() -> bool;
}
extern "C" {
    pub fn c4log_enableFatalExceptionBacktrace();
}
extern "C" {
    pub fn c4log(domain: C4LogDomain, level: C4LogLevel, fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn c4vlog(
        domain: C4LogDomain,
        level: C4LogLevel,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn c4slog(domain: C4LogDomain, level: C4LogLevel, msg: FLString);
}
pub type C4Slice = FLSlice;
pub type C4HeapSlice = FLHeapSlice;
pub type C4SliceResult = FLSliceResult;
pub type C4String = C4Slice;
pub type C4HeapString = C4HeapSlice;
pub type C4StringResult = C4SliceResult;
pub type C4SequenceNumber = u64;
pub type C4Timestamp = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4ExtraInfo {
    pub pointer: *mut ::std::os::raw::c_void,
    pub destructor: ::std::option::Option<unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void)>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4BlobStore {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Cert {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Collection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Database {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4CollectionObserver {
    _unused: [u8; 0],
}
pub type C4DatabaseObserver = C4CollectionObserver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DocumentObserver {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DocEnumerator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4KeyPair {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Listener {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Query {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4QueryObserver {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4ReadStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Replicator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4WriteStream {
    _unused: [u8; 0],
}
extern "C" {
    pub fn c4base_retain(obj: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn c4base_release(obj: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn c4doc_retain(arg1: *mut C4Document) -> *mut C4Document;
}
extern "C" {
    pub fn c4queryenum_retain(arg1: *mut C4QueryEnumerator) -> *mut C4QueryEnumerator;
}
extern "C" {
    pub fn c4socket_retain(arg1: *mut C4Socket) -> *mut C4Socket;
}
extern "C" {
    pub fn c4doc_release(arg1: *mut C4Document);
}
extern "C" {
    pub fn c4queryenum_release(arg1: *mut C4QueryEnumerator);
}
extern "C" {
    pub fn c4socket_release(arg1: *mut C4Socket);
}
extern "C" {
    pub fn c4dbobs_free(arg1: *mut C4CollectionObserver);
}
extern "C" {
    pub fn c4docobs_free(arg1: *mut C4DocumentObserver);
}
extern "C" {
    pub fn c4enum_free(arg1: *mut C4DocEnumerator);
}
extern "C" {
    pub fn c4listener_free(arg1: *mut C4Listener);
}
extern "C" {
    pub fn c4queryobs_free(arg1: *mut C4QueryObserver);
}
extern "C" {
    pub fn c4raw_free(arg1: *mut C4RawDocument);
}
extern "C" {
    pub fn c4repl_free(arg1: *mut C4Replicator);
}
extern "C" {
    pub fn c4stream_close(arg1: *mut C4ReadStream);
}
extern "C" {
    pub fn c4stream_closeWriter(arg1: *mut C4WriteStream);
}
extern "C" {
    pub fn c4_getObjectCount() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn c4_dumpInstances();
}
extern "C" {
    pub fn c4_getBuildInfo() -> C4StringResult;
}
extern "C" {
    pub fn c4_getVersion() -> C4StringResult;
}
extern "C" {
    pub fn c4_now() -> C4Timestamp;
}
extern "C" {
    pub fn c4_setTempDir(path: C4String, err: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4_runAsyncTask(
        task: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        context: *mut ::std::os::raw::c_void,
    );
}
pub type C4DocumentFlags = u32;
pub const kDocDeleted: u32 = 1;
pub const kDocConflicted: u32 = 2;
pub const kDocHasAttachments: u32 = 4;
pub const kDocExists: u32 = 4096;
pub type _bindgen_ty_57 = u32;
pub type C4RevisionFlags = u8;
pub const kRevDeleted: u8 = 1;
pub const kRevLeaf: u8 = 2;
pub const kRevNew: u8 = 4;
pub const kRevHasAttachments: u8 = 8;
pub const kRevKeepBody: u8 = 16;
pub const kRevIsConflict: u8 = 32;
pub const kRevClosed: u8 = 64;
pub const kRevPurged: u8 = 128;
pub type _bindgen_ty_58 = u8;
pub type C4RemoteID = u32;
impl C4DocContentLevel {
    pub const kDocGetMetadata: C4DocContentLevel = C4DocContentLevel(0);
}
impl C4DocContentLevel {
    pub const kDocGetCurrentRev: C4DocContentLevel = C4DocContentLevel(1);
}
impl C4DocContentLevel {
    pub const kDocGetAll: C4DocContentLevel = C4DocContentLevel(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4DocContentLevel(pub u8);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Revision {
    pub revID: C4HeapString,
    pub flags: C4RevisionFlags,
    pub sequence: C4SequenceNumber,
}
pub type C4DocDeltaApplier = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        doc: *mut C4Document,
        delta: C4Slice,
        outError: *mut C4Error,
    ) -> C4SliceResult,
>;
#[repr(C)]
#[derive(Debug)]
pub struct C4DocPutRequest {
    pub body: C4String,
    pub docID: C4String,
    pub revFlags: C4RevisionFlags,
    pub existingRevision: bool,
    pub allowConflict: bool,
    pub history: *const C4String,
    pub historyCount: usize,
    pub save: bool,
    pub maxRevTreeDepth: u32,
    pub remoteDBID: C4RemoteID,
    pub allocedBody: C4SliceResult,
    pub deltaCB: C4DocDeltaApplier,
    pub deltaCBContext: *mut ::std::os::raw::c_void,
    pub deltaSourceRevID: C4String,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4CollectionChange {
    pub docID: C4HeapString,
    pub revID: C4HeapString,
    pub sequence: C4SequenceNumber,
    pub bodySize: u32,
    pub flags: C4RevisionFlags,
}
pub type C4DatabaseChange = C4CollectionChange;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Document {
    pub _internal1: *mut ::std::os::raw::c_void,
    pub _internal2: *mut ::std::os::raw::c_void,
    pub flags: C4DocumentFlags,
    pub docID: C4HeapString,
    pub revID: C4HeapString,
    pub sequence: C4SequenceNumber,
    pub selectedRev: C4Revision,
    pub extraInfo: C4ExtraInfo,
}
extern "C" {
    pub fn c4doc_generateID(
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn c4db_getDoc(
        database: *mut C4Database,
        docID: C4String,
        mustExist: bool,
        content: C4DocContentLevel,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_get(
        database: *mut C4Database,
        docID: C4String,
        mustExist: bool,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_getBySequence(
        database: *mut C4Database,
        arg1: C4SequenceNumber,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_save(doc: *mut C4Document, maxRevTreeDepth: u32, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4doc_selectRevision(
        doc: *mut C4Document,
        revID: C4String,
        withBody: bool,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4doc_selectCurrentRevision(doc: *mut C4Document) -> bool;
}
extern "C" {
    pub fn c4doc_loadRevisionBody(doc: *mut C4Document, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4doc_hasRevisionBody(doc: *mut C4Document) -> bool;
}
extern "C" {
    pub fn c4doc_getRevisionBody(doc: *mut C4Document) -> C4Slice;
}
extern "C" {
    pub fn c4doc_getRevisionHistory(
        doc: *mut C4Document,
        maxRevs: ::std::os::raw::c_uint,
        backToRevs: *const C4String,
        backToRevsCount: ::std::os::raw::c_uint,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_getSelectedRevIDGlobalForm(doc: *mut C4Document) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_selectParentRevision(doc: *mut C4Document) -> bool;
}
extern "C" {
    pub fn c4doc_selectNextRevision(doc: *mut C4Document) -> bool;
}
extern "C" {
    pub fn c4doc_selectNextLeafRevision(
        doc: *mut C4Document,
        includeDeleted: bool,
        withBody: bool,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4doc_selectCommonAncestorRevision(
        doc: *mut C4Document,
        rev1ID: C4String,
        rev2ID: C4String,
    ) -> bool;
}
extern "C" {
    pub fn c4db_getRemoteDBID(
        db: *mut C4Database,
        remoteAddress: C4String,
        canCreate: bool,
        outError: *mut C4Error,
    ) -> C4RemoteID;
}
extern "C" {
    pub fn c4db_getRemoteDBAddress(db: *mut C4Database, remoteID: C4RemoteID) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_getRemoteAncestor(
        doc: *mut C4Document,
        remoteDatabase: C4RemoteID,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_setRemoteAncestor(
        doc: *mut C4Document,
        remoteDatabase: C4RemoteID,
        revID: C4String,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4rev_getGeneration(revID: C4String) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn c4rev_equal(rev1: C4Slice, rev2: C4Slice) -> bool;
}
extern "C" {
    pub fn c4doc_purgeRevision(
        doc: *mut C4Document,
        revID: C4String,
        outError: *mut C4Error,
    ) -> i32;
}
extern "C" {
    pub fn c4doc_resolveConflict(
        doc: *mut C4Document,
        winningRevID: C4String,
        losingRevID: C4String,
        mergedBody: C4Slice,
        mergedFlags: C4RevisionFlags,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_purgeDoc(
        database: *mut C4Database,
        docID: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4doc_setExpiration(
        db: *mut C4Database,
        docID: C4String,
        timestamp: C4Timestamp,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4doc_getExpiration(
        db: *mut C4Database,
        docID: C4String,
        outError: *mut C4Error,
    ) -> C4Timestamp;
}
extern "C" {
    pub fn c4doc_put(
        database: *mut C4Database,
        request: *const C4DocPutRequest,
        outCommonAncestorIndex: *mut usize,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_create(
        db: *mut C4Database,
        docID: C4String,
        body: C4Slice,
        revisionFlags: C4RevisionFlags,
        error: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_update(
        doc: *mut C4Document,
        revisionBody: C4Slice,
        revisionFlags: C4RevisionFlags,
        error: *mut C4Error,
    ) -> *mut C4Document;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLValue {
    _unused: [u8; 0],
}
pub type FLValue = *const _FLValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLArray {
    _unused: [u8; 0],
}
pub type FLArray = *const _FLArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLDict {
    _unused: [u8; 0],
}
pub type FLDict = *const _FLDict;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLSlot {
    _unused: [u8; 0],
}
pub type FLSlot = *mut _FLSlot;
pub type FLMutableArray = *mut _FLArray;
pub type FLMutableDict = *mut _FLDict;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLEncoder {
    _unused: [u8; 0],
}
pub type FLEncoder = *mut _FLEncoder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLDoc {
    _unused: [u8; 0],
}
pub type FLDoc = *mut _FLDoc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLSharedKeys {
    _unused: [u8; 0],
}
pub type FLSharedKeys = *mut _FLSharedKeys;
impl FLError {
    pub const kFLNoError: FLError = FLError(0);
}
impl FLError {
    pub const kFLMemoryError: FLError = FLError(1);
}
impl FLError {
    pub const kFLOutOfRange: FLError = FLError(2);
}
impl FLError {
    pub const kFLInvalidData: FLError = FLError(3);
}
impl FLError {
    pub const kFLEncodeError: FLError = FLError(4);
}
impl FLError {
    pub const kFLJSONError: FLError = FLError(5);
}
impl FLError {
    pub const kFLUnknownValue: FLError = FLError(6);
}
impl FLError {
    pub const kFLInternalError: FLError = FLError(7);
}
impl FLError {
    pub const kFLNotFound: FLError = FLError(8);
}
impl FLError {
    pub const kFLSharedKeysStateError: FLError = FLError(9);
}
impl FLError {
    pub const kFLPOSIXError: FLError = FLError(10);
}
impl FLError {
    pub const kFLUnsupported: FLError = FLError(11);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FLError(pub ::std::os::raw::c_uint);
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FLTrust {
    kFLUntrusted = 0,
    kFLTrusted = 1,
}
pub type FLTimestamp = i64;
extern "C" {
    pub fn FLTimestamp_Now() -> FLTimestamp;
}
extern "C" {
    pub fn FLTimestamp_ToString(timestamp: FLTimestamp, asUTC: bool) -> FLStringResult;
}
extern "C" {
    pub fn FLTimestamp_FromString(str_: FLString) -> FLTimestamp;
}
extern "C" {
    pub static kFLEmptyArray: FLArray;
}
extern "C" {
    pub fn FLArray_Count(arg1: FLArray) -> u32;
}
extern "C" {
    pub fn FLArray_IsEmpty(arg1: FLArray) -> bool;
}
extern "C" {
    pub fn FLArray_AsMutable(arg1: FLArray) -> FLMutableArray;
}
extern "C" {
    pub fn FLArray_Get(arg1: FLArray, index: u32) -> FLValue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLArrayIterator {
    pub _private1: *mut ::std::os::raw::c_void,
    pub _private2: u32,
    pub _private3: bool,
    pub _private4: *mut ::std::os::raw::c_void,
}
extern "C" {
    pub fn FLArrayIterator_Begin(arg1: FLArray, arg2: *mut FLArrayIterator);
}
extern "C" {
    pub fn FLArrayIterator_GetValue(arg1: *const FLArrayIterator) -> FLValue;
}
extern "C" {
    pub fn FLArrayIterator_GetValueAt(arg1: *const FLArrayIterator, offset: u32) -> FLValue;
}
extern "C" {
    pub fn FLArrayIterator_GetCount(arg1: *const FLArrayIterator) -> u32;
}
extern "C" {
    pub fn FLArrayIterator_Next(arg1: *mut FLArrayIterator) -> bool;
}
extern "C" {
    pub static kFLEmptyDict: FLDict;
}
extern "C" {
    pub fn FLDict_Count(arg1: FLDict) -> u32;
}
extern "C" {
    pub fn FLDict_IsEmpty(arg1: FLDict) -> bool;
}
extern "C" {
    pub fn FLDict_AsMutable(arg1: FLDict) -> FLMutableDict;
}
extern "C" {
    pub fn FLDict_Get(arg1: FLDict, keyString: FLSlice) -> FLValue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLDictIterator {
    pub _private1: *mut ::std::os::raw::c_void,
    pub _private2: u32,
    pub _private3: bool,
    pub _private4: *mut ::std::os::raw::c_void,
    pub _private5: *mut ::std::os::raw::c_void,
    pub _private6: *mut ::std::os::raw::c_void,
    pub _private7: *mut ::std::os::raw::c_void,
    pub _private8: ::std::os::raw::c_int,
}
extern "C" {
    pub fn FLDictIterator_Begin(arg1: FLDict, arg2: *mut FLDictIterator);
}
extern "C" {
    pub fn FLDictIterator_GetKey(arg1: *const FLDictIterator) -> FLValue;
}
extern "C" {
    pub fn FLDictIterator_GetKeyString(arg1: *const FLDictIterator) -> FLString;
}
extern "C" {
    pub fn FLDictIterator_GetValue(arg1: *const FLDictIterator) -> FLValue;
}
extern "C" {
    pub fn FLDictIterator_GetCount(arg1: *const FLDictIterator) -> u32;
}
extern "C" {
    pub fn FLDictIterator_Next(arg1: *mut FLDictIterator) -> bool;
}
extern "C" {
    pub fn FLDictIterator_End(arg1: *mut FLDictIterator);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLDictKey {
    pub _private1: FLSlice,
    pub _private2: *mut ::std::os::raw::c_void,
    pub _private3: u32,
    pub private4: u32,
    pub private5: bool,
}
extern "C" {
    pub fn FLDictKey_Init(string: FLSlice) -> FLDictKey;
}
extern "C" {
    pub fn FLDictKey_GetString(arg1: *const FLDictKey) -> FLString;
}
extern "C" {
    pub fn FLDict_GetWithKey(arg1: FLDict, arg2: *mut FLDictKey) -> FLValue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLDeepIterator {
    _unused: [u8; 0],
}
pub type FLDeepIterator = *mut _FLDeepIterator;
extern "C" {
    pub fn FLDeepIterator_New(arg1: FLValue) -> FLDeepIterator;
}
extern "C" {
    pub fn FLDeepIterator_Free(arg1: FLDeepIterator);
}
extern "C" {
    pub fn FLDeepIterator_GetValue(arg1: FLDeepIterator) -> FLValue;
}
extern "C" {
    pub fn FLDeepIterator_GetParent(arg1: FLDeepIterator) -> FLValue;
}
extern "C" {
    pub fn FLDeepIterator_GetKey(arg1: FLDeepIterator) -> FLSlice;
}
extern "C" {
    pub fn FLDeepIterator_GetIndex(arg1: FLDeepIterator) -> u32;
}
extern "C" {
    pub fn FLDeepIterator_GetDepth(arg1: FLDeepIterator) -> usize;
}
extern "C" {
    pub fn FLDeepIterator_SkipChildren(arg1: FLDeepIterator);
}
extern "C" {
    pub fn FLDeepIterator_Next(arg1: FLDeepIterator) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FLPathComponent {
    pub key: FLSlice,
    pub index: u32,
}
extern "C" {
    pub fn FLDeepIterator_GetPath(
        arg1: FLDeepIterator,
        outPath: *mut *mut FLPathComponent,
        outDepth: *mut usize,
    );
}
extern "C" {
    pub fn FLDeepIterator_GetPathString(arg1: FLDeepIterator) -> FLSliceResult;
}
extern "C" {
    pub fn FLDeepIterator_GetJSONPointer(arg1: FLDeepIterator) -> FLSliceResult;
}
extern "C" {
    pub fn FLDoc_FromResultData(
        data: FLSliceResult,
        arg1: FLTrust,
        arg2: FLSharedKeys,
        externData: FLSlice,
    ) -> FLDoc;
}
extern "C" {
    pub fn FLDoc_Release(arg1: FLDoc);
}
extern "C" {
    pub fn FLDoc_Retain(arg1: FLDoc) -> FLDoc;
}
extern "C" {
    pub fn FLDoc_GetData(arg1: FLDoc) -> FLSlice;
}
extern "C" {
    pub fn FLDoc_GetAllocedData(arg1: FLDoc) -> FLSliceResult;
}
extern "C" {
    pub fn FLDoc_GetRoot(arg1: FLDoc) -> FLValue;
}
extern "C" {
    pub fn FLDoc_GetSharedKeys(arg1: FLDoc) -> FLSharedKeys;
}
extern "C" {
    pub fn FLValue_FindDoc(arg1: FLValue) -> FLDoc;
}
extern "C" {
    pub fn FLDoc_SetAssociated(
        doc: FLDoc,
        pointer: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn FLDoc_GetAssociated(
        doc: FLDoc,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
pub const FLEncoderFormat_kFLEncodeFleece: FLEncoderFormat = 0;
pub const FLEncoderFormat_kFLEncodeJSON: FLEncoderFormat = 1;
pub const FLEncoderFormat_kFLEncodeJSON5: FLEncoderFormat = 2;
pub type FLEncoderFormat = ::std::os::raw::c_uint;
extern "C" {
    pub fn FLEncoder_New() -> FLEncoder;
}
extern "C" {
    pub fn FLEncoder_NewWithOptions(
        format: FLEncoderFormat,
        reserveSize: usize,
        uniqueStrings: bool,
    ) -> FLEncoder;
}
extern "C" {
    pub fn FLEncoder_NewWritingToFile(arg1: *mut FILE, uniqueStrings: bool) -> FLEncoder;
}
extern "C" {
    pub fn FLEncoder_Free(arg1: FLEncoder);
}
extern "C" {
    pub fn FLEncoder_SetSharedKeys(arg1: FLEncoder, arg2: FLSharedKeys);
}
extern "C" {
    pub fn FLEncoder_SetExtraInfo(arg1: FLEncoder, info: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn FLEncoder_GetExtraInfo(arg1: FLEncoder) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn FLEncoder_Reset(arg1: FLEncoder);
}
extern "C" {
    pub fn FLEncoder_BytesWritten(arg1: FLEncoder) -> usize;
}
extern "C" {
    pub fn FLEncoder_WriteNull(arg1: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteUndefined(arg1: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteBool(arg1: FLEncoder, arg2: bool) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteInt(arg1: FLEncoder, arg2: i64) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteUInt(arg1: FLEncoder, arg2: u64) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteFloat(arg1: FLEncoder, arg2: f32) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteDouble(arg1: FLEncoder, arg2: f64) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteString(arg1: FLEncoder, arg2: FLString) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteDateString(encoder: FLEncoder, ts: FLTimestamp, asUTC: bool) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteData(arg1: FLEncoder, arg2: FLSlice) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteValue(arg1: FLEncoder, arg2: FLValue) -> bool;
}
extern "C" {
    pub fn FLEncoder_BeginArray(arg1: FLEncoder, reserveCount: usize) -> bool;
}
extern "C" {
    pub fn FLEncoder_EndArray(arg1: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLEncoder_BeginDict(arg1: FLEncoder, reserveCount: usize) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteKey(arg1: FLEncoder, arg2: FLString) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteKeyValue(arg1: FLEncoder, arg2: FLValue) -> bool;
}
extern "C" {
    pub fn FLEncoder_EndDict(arg1: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLEncoder_WriteRaw(arg1: FLEncoder, arg2: FLSlice) -> bool;
}
extern "C" {
    pub fn FLEncoder_FinishDoc(arg1: FLEncoder, outError: *mut FLError) -> FLDoc;
}
extern "C" {
    pub fn FLEncoder_Finish(arg1: FLEncoder, outError: *mut FLError) -> FLSliceResult;
}
extern "C" {
    pub fn FLEncoder_GetError(arg1: FLEncoder) -> FLError;
}
extern "C" {
    pub fn FLEncoder_GetErrorMessage(arg1: FLEncoder) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FLValue_ToJSON(arg1: FLValue) -> FLStringResult;
}
extern "C" {
    pub fn FLValue_ToJSON5(arg1: FLValue) -> FLStringResult;
}
extern "C" {
    pub fn FLValue_ToJSONX(v: FLValue, json5: bool, canonicalForm: bool) -> FLStringResult;
}
extern "C" {
    pub fn FLDoc_FromJSON(json: FLSlice, outError: *mut FLError) -> FLDoc;
}
extern "C" {
    pub fn FLMutableArray_NewFromJSON(json: FLString, outError: *mut FLError) -> FLMutableArray;
}
extern "C" {
    pub fn FLMutableDict_NewFromJSON(json: FLString, outError: *mut FLError) -> FLMutableDict;
}
extern "C" {
    pub fn FLEncoder_ConvertJSON(arg1: FLEncoder, json: FLSlice) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLKeyPath {
    _unused: [u8; 0],
}
pub type FLKeyPath = *mut _FLKeyPath;
extern "C" {
    pub fn FLKeyPath_New(specifier: FLSlice, outError: *mut FLError) -> FLKeyPath;
}
extern "C" {
    pub fn FLKeyPath_Free(arg1: FLKeyPath);
}
extern "C" {
    pub fn FLKeyPath_Eval(arg1: FLKeyPath, root: FLValue) -> FLValue;
}
extern "C" {
    pub fn FLKeyPath_EvalOnce(specifier: FLSlice, root: FLValue, outError: *mut FLError)
        -> FLValue;
}
extern "C" {
    pub fn FLKeyPath_ToString(path: FLKeyPath) -> FLStringResult;
}
extern "C" {
    pub fn FLKeyPath_Equals(path1: FLKeyPath, path2: FLKeyPath) -> bool;
}
extern "C" {
    pub fn FLKeyPath_GetElement(
        arg1: FLKeyPath,
        i: usize,
        outDictKey: *mut FLSlice,
        outArrayIndex: *mut i32,
    ) -> bool;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FLValueType {
    kFLUndefined = -1,
    kFLNull = 0,
    kFLBoolean = 1,
    kFLNumber = 2,
    kFLString = 3,
    kFLData = 4,
    kFLArray = 5,
    kFLDict = 6,
}
extern "C" {
    pub static kFLNullValue: FLValue;
}
extern "C" {
    pub static kFLUndefinedValue: FLValue;
}
extern "C" {
    pub fn FLValue_GetType(arg1: FLValue) -> FLValueType;
}
extern "C" {
    pub fn FLValue_IsInteger(arg1: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_IsUnsigned(arg1: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_IsDouble(arg1: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_AsBool(arg1: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_AsInt(arg1: FLValue) -> i64;
}
extern "C" {
    pub fn FLValue_AsUnsigned(arg1: FLValue) -> u64;
}
extern "C" {
    pub fn FLValue_AsFloat(arg1: FLValue) -> f32;
}
extern "C" {
    pub fn FLValue_AsDouble(arg1: FLValue) -> f64;
}
extern "C" {
    pub fn FLValue_AsString(arg1: FLValue) -> FLString;
}
extern "C" {
    pub fn FLValue_AsTimestamp(arg1: FLValue) -> FLTimestamp;
}
extern "C" {
    pub fn FLValue_AsData(arg1: FLValue) -> FLSlice;
}
extern "C" {
    pub fn FLValue_AsArray(arg1: FLValue) -> FLArray;
}
extern "C" {
    pub fn FLValue_AsDict(arg1: FLValue) -> FLDict;
}
extern "C" {
    pub fn FLValue_ToString(arg1: FLValue) -> FLStringResult;
}
extern "C" {
    pub fn FLValue_IsEqual(v1: FLValue, v2: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_IsMutable(arg1: FLValue) -> bool;
}
extern "C" {
    pub fn FLValue_Retain(arg1: FLValue) -> FLValue;
}
extern "C" {
    pub fn FLValue_Release(arg1: FLValue);
}
pub const FLCopyFlags_kFLDefaultCopy: FLCopyFlags = 0;
pub const FLCopyFlags_kFLDeepCopy: FLCopyFlags = 1;
pub const FLCopyFlags_kFLCopyImmutables: FLCopyFlags = 2;
pub const FLCopyFlags_kFLDeepCopyImmutables: FLCopyFlags = 3;
pub type FLCopyFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn FLArray_MutableCopy(arg1: FLArray, arg2: FLCopyFlags) -> FLMutableArray;
}
extern "C" {
    pub fn FLMutableArray_New() -> FLMutableArray;
}
extern "C" {
    pub fn FLMutableArray_GetSource(arg1: FLMutableArray) -> FLArray;
}
extern "C" {
    pub fn FLMutableArray_IsChanged(arg1: FLMutableArray) -> bool;
}
extern "C" {
    pub fn FLMutableArray_SetChanged(arg1: FLMutableArray, changed: bool);
}
extern "C" {
    pub fn FLMutableArray_Insert(array: FLMutableArray, firstIndex: u32, count: u32);
}
extern "C" {
    pub fn FLMutableArray_Remove(array: FLMutableArray, firstIndex: u32, count: u32);
}
extern "C" {
    pub fn FLMutableArray_Resize(array: FLMutableArray, size: u32);
}
extern "C" {
    pub fn FLMutableArray_GetMutableArray(arg1: FLMutableArray, index: u32) -> FLMutableArray;
}
extern "C" {
    pub fn FLMutableArray_GetMutableDict(arg1: FLMutableArray, index: u32) -> FLMutableDict;
}
extern "C" {
    pub fn FLDict_MutableCopy(source: FLDict, arg1: FLCopyFlags) -> FLMutableDict;
}
extern "C" {
    pub fn FLMutableDict_New() -> FLMutableDict;
}
extern "C" {
    pub fn FLMutableDict_GetSource(arg1: FLMutableDict) -> FLDict;
}
extern "C" {
    pub fn FLMutableDict_IsChanged(arg1: FLMutableDict) -> bool;
}
extern "C" {
    pub fn FLMutableDict_SetChanged(arg1: FLMutableDict, arg2: bool);
}
extern "C" {
    pub fn FLMutableDict_Remove(arg1: FLMutableDict, key: FLString);
}
extern "C" {
    pub fn FLMutableDict_RemoveAll(arg1: FLMutableDict);
}
extern "C" {
    pub fn FLMutableDict_GetMutableArray(arg1: FLMutableDict, key: FLString) -> FLMutableArray;
}
extern "C" {
    pub fn FLMutableDict_GetMutableDict(arg1: FLMutableDict, key: FLString) -> FLMutableDict;
}
extern "C" {
    pub fn FLValue_NewString(arg1: FLString) -> FLValue;
}
extern "C" {
    pub fn FLValue_NewData(arg1: FLSlice) -> FLValue;
}
extern "C" {
    pub fn FLMutableArray_Set(arg1: FLMutableArray, index: u32) -> FLSlot;
}
extern "C" {
    pub fn FLMutableArray_Append(arg1: FLMutableArray) -> FLSlot;
}
extern "C" {
    pub fn FLMutableDict_Set(arg1: FLMutableDict, key: FLString) -> FLSlot;
}
extern "C" {
    pub fn FLSlot_SetNull(arg1: FLSlot);
}
extern "C" {
    pub fn FLSlot_SetBool(arg1: FLSlot, arg2: bool);
}
extern "C" {
    pub fn FLSlot_SetInt(arg1: FLSlot, arg2: i64);
}
extern "C" {
    pub fn FLSlot_SetUInt(arg1: FLSlot, arg2: u64);
}
extern "C" {
    pub fn FLSlot_SetFloat(arg1: FLSlot, arg2: f32);
}
extern "C" {
    pub fn FLSlot_SetDouble(arg1: FLSlot, arg2: f64);
}
extern "C" {
    pub fn FLSlot_SetString(arg1: FLSlot, arg2: FLString);
}
extern "C" {
    pub fn FLSlot_SetData(arg1: FLSlot, arg2: FLSlice);
}
extern "C" {
    pub fn FLSlot_SetValue(arg1: FLSlot, arg2: FLValue);
}
extern "C" {
    pub fn c4doc_getProperties(arg1: *mut C4Document) -> FLDict;
}
extern "C" {
    pub fn c4doc_createFleeceDoc(arg1: *mut C4Document) -> FLDoc;
}
extern "C" {
    pub fn c4doc_resolveConflict2(
        doc: *mut C4Document,
        winningRevID: C4String,
        losingRevID: C4String,
        mergedProperties: FLDict,
        mergedFlags: C4RevisionFlags,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4doc_containingValue(value: FLValue) -> *mut C4Document;
}
extern "C" {
    pub fn c4doc_isOldMetaProperty(prop: C4String) -> bool;
}
extern "C" {
    pub fn c4doc_hasOldMetaProperties(doc: FLDict) -> bool;
}
extern "C" {
    pub fn c4doc_encodeStrippingOldMetaProperties(
        doc: FLDict,
        sk: FLSharedKeys,
        outError: *mut C4Error,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_getDictBlobKey(dict: FLDict, outKey: *mut C4BlobKey) -> bool;
}
extern "C" {
    pub fn c4doc_dictIsBlob(dict: FLDict, outKey: *mut C4BlobKey) -> bool;
}
extern "C" {
    pub fn c4doc_dictContainsBlobs(dict: FLDict) -> bool;
}
extern "C" {
    pub fn c4doc_getBlobData(
        dict: FLDict,
        blobStore: *mut C4BlobStore,
        outError: *mut C4Error,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4doc_blobIsCompressible(blobDict: FLDict) -> bool;
}
extern "C" {
    pub fn c4doc_bodyAsJSON(
        doc: *mut C4Document,
        canonical: bool,
        outError: *mut C4Error,
    ) -> C4StringResult;
}
extern "C" {
    pub fn c4db_createFleeceEncoder(db: *mut C4Database) -> FLEncoder;
}
extern "C" {
    pub fn c4db_getSharedFleeceEncoder(db: *mut C4Database) -> FLEncoder;
}
extern "C" {
    pub fn c4db_encodeJSON(
        arg1: *mut C4Database,
        jsonData: C4String,
        outError: *mut C4Error,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4db_getFLSharedKeys(db: *mut C4Database) -> FLSharedKeys;
}
extern "C" {
    pub fn FLCreateJSONDelta(old: FLValue, nuu: FLValue) -> FLSliceResult;
}
extern "C" {
    pub fn FLEncodeJSONDelta(old: FLValue, nuu: FLValue, jsonEncoder: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLApplyJSONDelta(
        old: FLValue,
        jsonDelta: FLSlice,
        outError: *mut FLError,
    ) -> FLSliceResult;
}
extern "C" {
    pub fn FLEncodeApplyingJSONDelta(old: FLValue, jsonDelta: FLSlice, encoder: FLEncoder) -> bool;
}
extern "C" {
    pub fn FLSharedKeys_New() -> FLSharedKeys;
}
pub type FLSharedKeysReadCallback = ::std::option::Option<
    unsafe extern "C" fn(context: *mut ::std::os::raw::c_void, arg1: FLSharedKeys) -> bool,
>;
extern "C" {
    pub fn FLSharedKeys_NewWithRead(
        arg1: FLSharedKeysReadCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> FLSharedKeys;
}
extern "C" {
    pub fn FLSharedKeys_GetStateData(arg1: FLSharedKeys) -> FLSliceResult;
}
extern "C" {
    pub fn FLSharedKeys_LoadStateData(arg1: FLSharedKeys, arg2: FLSlice) -> bool;
}
extern "C" {
    pub fn FLSharedKeys_WriteState(arg1: FLSharedKeys, arg2: FLEncoder);
}
extern "C" {
    pub fn FLSharedKeys_LoadState(arg1: FLSharedKeys, arg2: FLValue) -> bool;
}
extern "C" {
    pub fn FLSharedKeys_Encode(
        arg1: FLSharedKeys,
        arg2: FLString,
        add: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FLSharedKeys_Decode(arg1: FLSharedKeys, key: ::std::os::raw::c_int) -> FLString;
}
extern "C" {
    pub fn FLSharedKeys_Count(arg1: FLSharedKeys) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FLSharedKeys_RevertToCount(arg1: FLSharedKeys, oldCount: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn FLSharedKeys_Retain(arg1: FLSharedKeys) -> FLSharedKeys;
}
extern "C" {
    pub fn FLSharedKeys_Release(arg1: FLSharedKeys);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLSharedKeyScope {
    _unused: [u8; 0],
}
pub type FLSharedKeyScope = *mut _FLSharedKeyScope;
extern "C" {
    pub fn FLSharedKeyScope_WithRange(range: FLSlice, arg1: FLSharedKeys) -> FLSharedKeyScope;
}
extern "C" {
    pub fn FLSharedKeyScope_Free(arg1: FLSharedKeyScope);
}
extern "C" {
    pub fn FLValue_FromData(data: FLSlice, trust: FLTrust) -> FLValue;
}
extern "C" {
    pub fn FLJSON5_ToJSON(
        json5: FLString,
        outErrorMessage: *mut FLStringResult,
        outErrorPos: *mut usize,
        outError: *mut FLError,
    ) -> FLStringResult;
}
extern "C" {
    pub fn FLData_ConvertJSON(json: FLSlice, outError: *mut FLError) -> FLSliceResult;
}
extern "C" {
    pub fn FLEncoder_Amend(e: FLEncoder, base: FLSlice, reuseStrings: bool, externPointers: bool);
}
extern "C" {
    pub fn FLEncoder_GetBase(arg1: FLEncoder) -> FLSlice;
}
extern "C" {
    pub fn FLEncoder_SuppressTrailer(arg1: FLEncoder);
}
extern "C" {
    pub fn FLEncoder_GetNextWritePos(arg1: FLEncoder) -> usize;
}
extern "C" {
    pub fn FLEncoder_LastValueWritten(arg1: FLEncoder) -> isize;
}
extern "C" {
    pub fn FLEncoder_WriteValueAgain(arg1: FLEncoder, preWrittenValue: isize);
}
extern "C" {
    pub fn FLEncoder_Snip(arg1: FLEncoder) -> FLSliceResult;
}
extern "C" {
    pub fn FLEncoder_FinishItem(arg1: FLEncoder) -> usize;
}
extern "C" {
    pub fn FLDump(arg1: FLValue) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FLDumpData(data: FLSlice) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn FLData_Dump(data: FLSlice) -> FLStringResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4BlobKey {
    pub bytes: [u8; 20usize],
}
pub type C4BlobKey_slice = fleece_slice;
extern "C" {
    #[link_name = "\u{1}_ZN9C4BlobKey22computeDigestOfContentEN6fleece5sliceE"]
    pub fn C4BlobKey_computeDigestOfContent(content: C4BlobKey_slice) -> C4BlobKey;
}
extern "C" {
    #[link_name = "\u{1}_ZN9C4BlobKey16withDigestStringEN6fleece5sliceE"]
    pub fn C4BlobKey_withDigestString(base64: C4BlobKey_slice) -> std_optional;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9C4BlobKey12digestStringB5cxx11Ev"]
    pub fn C4BlobKey_digestString(this: *const C4BlobKey) -> std_string;
}
impl C4BlobKey {
    #[inline]
    pub unsafe fn computeDigestOfContent(content: C4BlobKey_slice) -> C4BlobKey {
        C4BlobKey_computeDigestOfContent(content)
    }
    #[inline]
    pub unsafe fn withDigestString(base64: C4BlobKey_slice) -> std_optional {
        C4BlobKey_withDigestString(base64)
    }
    #[inline]
    pub unsafe fn digestString(&self) -> std_string {
        C4BlobKey_digestString(self)
    }
}
pub type C4DatabaseFlags = u32;
pub const kC4DB_Create: u32 = 1;
pub const kC4DB_ReadOnly: u32 = 2;
pub const kC4DB_AutoCompact: u32 = 4;
pub const kC4DB_VersionVectors: u32 = 8;
pub const kC4DB_NoUpgrade: u32 = 32;
pub const kC4DB_NonObservable: u32 = 64;
pub type _bindgen_ty_59 = u32;
impl C4EncryptionAlgorithm {
    pub const kC4EncryptionNone: C4EncryptionAlgorithm = C4EncryptionAlgorithm(0);
}
impl C4EncryptionAlgorithm {
    pub const kC4EncryptionAES256: C4EncryptionAlgorithm = C4EncryptionAlgorithm(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4EncryptionAlgorithm(pub u32);
impl C4EncryptionKeySize {
    pub const kC4EncryptionKeySizeAES256: C4EncryptionKeySize = C4EncryptionKeySize(32);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4EncryptionKeySize(pub u64);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4EncryptionKey {
    pub algorithm: C4EncryptionAlgorithm,
    pub bytes: [u8; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DatabaseConfig2 {
    pub parentDirectory: C4Slice,
    pub flags: C4DatabaseFlags,
    pub encryptionKey: C4EncryptionKey,
}
extern "C" {
    pub static kC4DatabaseFilenameExtension: *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4UUID {
    pub bytes: [u8; 16usize],
}
impl C4MaintenanceType {
    pub const kC4Compact: C4MaintenanceType = C4MaintenanceType(0);
}
impl C4MaintenanceType {
    pub const kC4Reindex: C4MaintenanceType = C4MaintenanceType(1);
}
impl C4MaintenanceType {
    pub const kC4IntegrityCheck: C4MaintenanceType = C4MaintenanceType(2);
}
impl C4MaintenanceType {
    pub const kC4QuickOptimize: C4MaintenanceType = C4MaintenanceType(3);
}
impl C4MaintenanceType {
    pub const kC4FullOptimize: C4MaintenanceType = C4MaintenanceType(4);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4MaintenanceType(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4RawDocument {
    pub key: C4String,
    pub meta: C4String,
    pub body: C4String,
}
impl C4DocumentVersioning {
    pub const kC4TreeVersioning_v2: C4DocumentVersioning = C4DocumentVersioning(0);
}
impl C4DocumentVersioning {
    pub const kC4TreeVersioning: C4DocumentVersioning = C4DocumentVersioning(1);
}
impl C4DocumentVersioning {
    pub const kC4VectorVersioning: C4DocumentVersioning = C4DocumentVersioning(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4DocumentVersioning(pub u32);
pub type C4StorageEngine = *const ::std::os::raw::c_char;
extern "C" {
    pub static kC4SQLiteStorageEngine: C4StorageEngine;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DatabaseConfig {
    pub flags: C4DatabaseFlags,
    pub storageEngine: C4StorageEngine,
    pub versioning: C4DocumentVersioning,
    pub encryptionKey: C4EncryptionKey,
}
extern "C" {
    pub fn c4blob_keyFromString(str_: C4String, arg1: *mut C4BlobKey) -> bool;
}
extern "C" {
    pub fn c4blob_keyToString(arg1: C4BlobKey) -> C4StringResult;
}
extern "C" {
    pub fn c4db_getBlobStore(db: *mut C4Database, outError: *mut C4Error) -> *mut C4BlobStore;
}
extern "C" {
    pub fn c4blob_openStore(
        dirPath: C4String,
        flags: C4DatabaseFlags,
        encryptionKey: *const C4EncryptionKey,
        outError: *mut C4Error,
    ) -> *mut C4BlobStore;
}
extern "C" {
    pub fn c4blob_freeStore(arg1: *mut C4BlobStore);
}
extern "C" {
    pub fn c4blob_deleteStore(arg1: *mut C4BlobStore, arg2: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4blob_getSize(arg1: *mut C4BlobStore, arg2: C4BlobKey) -> i64;
}
extern "C" {
    pub fn c4blob_getContents(
        arg1: *mut C4BlobStore,
        arg2: C4BlobKey,
        arg3: *mut C4Error,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4blob_getFilePath(
        arg1: *mut C4BlobStore,
        arg2: C4BlobKey,
        arg3: *mut C4Error,
    ) -> C4StringResult;
}
extern "C" {
    pub fn c4blob_computeKey(contents: C4Slice) -> C4BlobKey;
}
extern "C" {
    pub fn c4blob_create(
        store: *mut C4BlobStore,
        contents: C4Slice,
        expectedKey: *const C4BlobKey,
        outKey: *mut C4BlobKey,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4blob_delete(arg1: *mut C4BlobStore, arg2: C4BlobKey, arg3: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4blob_openReadStream(
        arg1: *mut C4BlobStore,
        arg2: C4BlobKey,
        arg3: *mut C4Error,
    ) -> *mut C4ReadStream;
}
extern "C" {
    pub fn c4stream_read(
        stream: *mut C4ReadStream,
        buffer: *mut ::std::os::raw::c_void,
        maxBytesToRead: usize,
        error: *mut C4Error,
    ) -> usize;
}
extern "C" {
    pub fn c4stream_getLength(arg1: *mut C4ReadStream, arg2: *mut C4Error) -> i64;
}
extern "C" {
    pub fn c4stream_seek(arg1: *mut C4ReadStream, position: u64, arg2: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4blob_openWriteStream(arg1: *mut C4BlobStore, arg2: *mut C4Error)
        -> *mut C4WriteStream;
}
extern "C" {
    pub fn c4stream_write(
        arg1: *mut C4WriteStream,
        bytes: *const ::std::os::raw::c_void,
        length: usize,
        arg2: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4stream_bytesWritten(arg1: *mut C4WriteStream) -> u64;
}
extern "C" {
    pub fn c4stream_computeBlobKey(arg1: *mut C4WriteStream) -> C4BlobKey;
}
extern "C" {
    pub fn c4stream_install(
        arg1: *mut C4WriteStream,
        expectedKey: *const C4BlobKey,
        arg2: *mut C4Error,
    ) -> bool;
}
impl C4QueryLanguage {
    pub const kC4JSONQuery: C4QueryLanguage = C4QueryLanguage(0);
}
impl C4QueryLanguage {
    pub const kC4N1QLQuery: C4QueryLanguage = C4QueryLanguage(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4QueryLanguage(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4QueryOptions {
    pub rankFullText_DEPRECATED: bool,
}
extern "C" {
    pub static kC4DefaultQueryOptions: C4QueryOptions;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4FullTextMatch {
    pub dataSource: u64,
    pub property: u32,
    pub term: u32,
    pub start: u32,
    pub length: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4QueryEnumerator {
    pub columns: FLArrayIterator,
    pub missingColumns: u64,
    pub fullTextMatchCount: u32,
    pub fullTextMatches: *const C4FullTextMatch,
}
impl C4IndexType {
    pub const kC4ValueIndex: C4IndexType = C4IndexType(0);
}
impl C4IndexType {
    pub const kC4FullTextIndex: C4IndexType = C4IndexType(1);
}
impl C4IndexType {
    pub const kC4ArrayIndex: C4IndexType = C4IndexType(2);
}
impl C4IndexType {
    pub const kC4PredictiveIndex: C4IndexType = C4IndexType(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4IndexType(pub u32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4IndexOptions {
    pub language: *const ::std::os::raw::c_char,
    pub ignoreDiacritics: bool,
    pub disableStemming: bool,
    pub stopWords: *const ::std::os::raw::c_char,
}
extern "C" {
    pub fn c4db_getDefaultCollection(db: *mut C4Database) -> *mut C4Collection;
}
extern "C" {
    pub fn c4db_hasCollection(db: *mut C4Database, name: C4String) -> bool;
}
extern "C" {
    pub fn c4db_getCollection(db: *mut C4Database, name: C4String) -> *mut C4Collection;
}
extern "C" {
    pub fn c4db_createCollection(
        db: *mut C4Database,
        name: C4String,
        outError: *mut C4Error,
    ) -> *mut C4Collection;
}
extern "C" {
    pub fn c4db_deleteCollection(
        db: *mut C4Database,
        name: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_collectionNames(db: *mut C4Database) -> C4StringResult;
}
extern "C" {
    pub fn c4coll_getName(arg1: *mut C4Collection) -> C4String;
}
extern "C" {
    pub fn c4coll_getDatabase(arg1: *mut C4Collection) -> *mut C4Database;
}
extern "C" {
    pub fn c4coll_getDocumentCount(arg1: *mut C4Collection) -> u64;
}
extern "C" {
    pub fn c4coll_getLastSequence(arg1: *mut C4Collection) -> C4SequenceNumber;
}
extern "C" {
    pub fn c4coll_getDoc(
        collection: *mut C4Collection,
        docID: C4String,
        mustExist: bool,
        content: C4DocContentLevel,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4coll_getDocBySequence(
        collection: *mut C4Collection,
        arg1: C4SequenceNumber,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4coll_putDoc(
        collection: *mut C4Collection,
        request: *const C4DocPutRequest,
        outCommonAncestorIndex: *mut usize,
        outError: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4coll_createDoc(
        collection: *mut C4Collection,
        docID: C4String,
        body: C4Slice,
        revisionFlags: C4RevisionFlags,
        error: *mut C4Error,
    ) -> *mut C4Document;
}
extern "C" {
    pub fn c4coll_moveDoc(
        collection: *mut C4Collection,
        docID: C4String,
        toCollection: *mut C4Collection,
        newDocID: C4String,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4coll_purgeDoc(
        collection: *mut C4Collection,
        docID: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4coll_setDocExpiration(
        collection: *mut C4Collection,
        docID: C4String,
        timestamp: C4Timestamp,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4coll_getDocExpiration(
        collection: *mut C4Collection,
        docID: C4String,
        outError: *mut C4Error,
    ) -> C4Timestamp;
}
extern "C" {
    pub fn c4coll_nextDocExpiration(arg1: *mut C4Collection) -> C4Timestamp;
}
extern "C" {
    pub fn c4coll_purgeExpiredDocs(arg1: *mut C4Collection, arg2: *mut C4Error) -> i64;
}
extern "C" {
    pub fn c4coll_createIndex(
        collection: *mut C4Collection,
        name: C4String,
        indexSpec: C4String,
        queryLanguage: C4QueryLanguage,
        indexType: C4IndexType,
        indexOptions: *const C4IndexOptions,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4coll_deleteIndex(
        collection: *mut C4Collection,
        name: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4coll_getIndexesInfo(
        collection: *mut C4Collection,
        outError: *mut C4Error,
    ) -> C4SliceResult;
}
extern "C" {
    pub fn c4key_setPassword(
        encryptionKey: *mut C4EncryptionKey,
        password: C4String,
        alg: C4EncryptionAlgorithm,
    ) -> bool;
}
extern "C" {
    pub fn c4key_setPasswordSHA1(
        encryptionKey: *mut C4EncryptionKey,
        password: C4String,
        alg: C4EncryptionAlgorithm,
    ) -> bool;
}
extern "C" {
    pub fn c4db_exists(name: C4String, inDirectory: C4String) -> bool;
}
extern "C" {
    pub fn c4db_openNamed(
        name: C4String,
        config: *const C4DatabaseConfig2,
        outError: *mut C4Error,
    ) -> *mut C4Database;
}
extern "C" {
    pub fn c4db_openAgain(db: *mut C4Database, outError: *mut C4Error) -> *mut C4Database;
}
extern "C" {
    pub fn c4db_copyNamed(
        sourcePath: C4String,
        destinationName: C4String,
        config: *const C4DatabaseConfig2,
        error: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_close(database: *mut C4Database, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4db_delete(database: *mut C4Database, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4db_deleteNamed(
        dbName: C4String,
        inDirectory: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_rekey(
        database: *mut C4Database,
        newKey: *const C4EncryptionKey,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4_shutdown(outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4db_getName(arg1: *mut C4Database) -> C4String;
}
extern "C" {
    pub fn c4db_getPath(arg1: *mut C4Database) -> C4StringResult;
}
extern "C" {
    pub fn c4db_getConfig2(database: *mut C4Database) -> *const C4DatabaseConfig2;
}
extern "C" {
    pub fn c4db_getDocumentCount(database: *mut C4Database) -> u64;
}
extern "C" {
    pub fn c4db_getLastSequence(database: *mut C4Database) -> C4SequenceNumber;
}
extern "C" {
    pub fn c4db_nextDocExpiration(database: *mut C4Database) -> C4Timestamp;
}
extern "C" {
    pub fn c4db_purgeExpiredDocs(db: *mut C4Database, arg1: *mut C4Error) -> i64;
}
extern "C" {
    pub fn c4db_getUUIDs(
        database: *mut C4Database,
        publicUUID: *mut C4UUID,
        privateUUID: *mut C4UUID,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_setExtraInfo(database: *mut C4Database, arg1: C4ExtraInfo);
}
extern "C" {
    pub fn c4db_getExtraInfo(database: *mut C4Database) -> C4ExtraInfo;
}
extern "C" {
    pub fn c4db_maintenance(
        database: *mut C4Database,
        type_: C4MaintenanceType,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_beginTransaction(database: *mut C4Database, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4db_endTransaction(
        database: *mut C4Database,
        commit: bool,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_isInTransaction(database: *mut C4Database) -> bool;
}
extern "C" {
    pub fn c4raw_get(
        database: *mut C4Database,
        storeName: C4String,
        docID: C4String,
        outError: *mut C4Error,
    ) -> *mut C4RawDocument;
}
extern "C" {
    pub fn c4raw_put(
        database: *mut C4Database,
        storeName: C4String,
        key: C4String,
        meta: C4String,
        body: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
pub type C4EnumeratorFlags = u16;
pub const kC4Descending: u16 = 1;
pub const kC4Unsorted: u16 = 2;
pub const kC4IncludeDeleted: u16 = 8;
pub const kC4IncludeNonConflicted: u16 = 16;
pub const kC4IncludeBodies: u16 = 32;
pub const kC4IncludeRevHistory: u16 = 64;
pub type _bindgen_ty_60 = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4EnumeratorOptions {
    pub flags: C4EnumeratorFlags,
}
extern "C" {
    pub static kC4DefaultEnumeratorOptions: C4EnumeratorOptions;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DocumentInfo {
    pub flags: C4DocumentFlags,
    pub docID: C4HeapString,
    pub revID: C4HeapString,
    pub sequence: C4SequenceNumber,
    pub bodySize: u64,
    pub metaSize: u64,
    pub expiration: C4Timestamp,
}
extern "C" {
    pub fn c4enum_close(e: *mut C4DocEnumerator);
}
extern "C" {
    pub fn c4db_enumerateChanges(
        database: *mut C4Database,
        since: C4SequenceNumber,
        options: *const C4EnumeratorOptions,
        outError: *mut C4Error,
    ) -> *mut C4DocEnumerator;
}
extern "C" {
    pub fn c4db_enumerateAllDocs(
        database: *mut C4Database,
        options: *const C4EnumeratorOptions,
        outError: *mut C4Error,
    ) -> *mut C4DocEnumerator;
}
extern "C" {
    pub fn c4coll_enumerateChanges(
        collection: *mut C4Collection,
        since: C4SequenceNumber,
        options: *const C4EnumeratorOptions,
        outError: *mut C4Error,
    ) -> *mut C4DocEnumerator;
}
extern "C" {
    pub fn c4coll_enumerateAllDocs(
        collection: *mut C4Collection,
        options: *const C4EnumeratorOptions,
        outError: *mut C4Error,
    ) -> *mut C4DocEnumerator;
}
extern "C" {
    pub fn c4enum_next(e: *mut C4DocEnumerator, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4enum_getDocument(e: *mut C4DocEnumerator, outError: *mut C4Error) -> *mut C4Document;
}
extern "C" {
    pub fn c4enum_getDocumentInfo(e: *mut C4DocEnumerator, outInfo: *mut C4DocumentInfo) -> bool;
}
extern "C" {
    pub fn c4db_createIndex(
        database: *mut C4Database,
        name: C4String,
        indexSpecJSON: C4String,
        indexType: C4IndexType,
        indexOptions: *const C4IndexOptions,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_createIndex2(
        database: *mut C4Database,
        name: C4String,
        indexSpec: C4String,
        queryLanguage: C4QueryLanguage,
        indexType: C4IndexType,
        indexOptions: *const C4IndexOptions,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_deleteIndex(
        database: *mut C4Database,
        name: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_getIndexesInfo(database: *mut C4Database, outError: *mut C4Error) -> C4SliceResult;
}
pub type C4ListenerAPIs = ::std::os::raw::c_uint;
pub const kC4RESTAPI: ::std::os::raw::c_uint = 1;
pub const kC4SyncAPI: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
impl C4PrivateKeyRepresentation {
    pub const kC4PrivateKeyFromCert: C4PrivateKeyRepresentation = C4PrivateKeyRepresentation(0);
}
impl C4PrivateKeyRepresentation {
    pub const kC4PrivateKeyFromKey: C4PrivateKeyRepresentation = C4PrivateKeyRepresentation(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4PrivateKeyRepresentation(pub ::std::os::raw::c_uint);
pub type C4ListenerCertAuthCallback = ::std::option::Option<
    unsafe extern "C" fn(
        listener: *mut C4Listener,
        clientCertData: C4Slice,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type C4ListenerHTTPAuthCallback = ::std::option::Option<
    unsafe extern "C" fn(
        listener: *mut C4Listener,
        authHeader: C4Slice,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4TLSConfig {
    pub privateKeyRepresentation: C4PrivateKeyRepresentation,
    pub key: *mut C4KeyPair,
    pub certificate: *mut C4Cert,
    pub requireClientCerts: bool,
    pub rootClientCerts: *mut C4Cert,
    pub certAuthCallback: C4ListenerCertAuthCallback,
    pub tlsCallbackContext: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4ListenerConfig {
    pub port: u16,
    pub networkInterface: C4String,
    pub apis: C4ListenerAPIs,
    pub tlsConfig: *mut C4TLSConfig,
    pub httpAuthCallback: C4ListenerHTTPAuthCallback,
    pub callbackContext: *mut ::std::os::raw::c_void,
    pub directory: C4String,
    pub allowCreateDBs: bool,
    pub allowDeleteDBs: bool,
    pub allowPush: bool,
    pub allowPull: bool,
    pub enableDeltaSync: bool,
}
extern "C" {
    pub fn c4listener_availableAPIs() -> C4ListenerAPIs;
}
extern "C" {
    pub fn c4listener_start(
        config: *const C4ListenerConfig,
        error: *mut C4Error,
    ) -> *mut C4Listener;
}
extern "C" {
    pub fn c4listener_shareDB(
        listener: *mut C4Listener,
        name: C4String,
        db: *mut C4Database,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4listener_unshareDB(
        listener: *mut C4Listener,
        db: *mut C4Database,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4listener_getURLs(
        listener: *const C4Listener,
        db: *mut C4Database,
        api: C4ListenerAPIs,
        err: *mut C4Error,
    ) -> FLMutableArray;
}
extern "C" {
    pub fn c4listener_getPort(listener: *const C4Listener) -> u16;
}
extern "C" {
    pub fn c4listener_getConnectionStatus(
        listener: *const C4Listener,
        connectionCount: *mut ::std::os::raw::c_uint,
        activeConnectionCount: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn c4db_URINameFromPath(path: C4String) -> C4StringResult;
}
pub type C4CollectionObserverCallback = ::std::option::Option<
    unsafe extern "C" fn(observer: *mut C4CollectionObserver, context: *mut ::std::os::raw::c_void),
>;
pub type C4DatabaseObserverCallback = C4CollectionObserverCallback;
extern "C" {
    pub fn c4dbobs_create(
        database: *mut C4Database,
        callback: C4DatabaseObserverCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut C4DatabaseObserver;
}
extern "C" {
    pub fn c4dbobs_createOnCollection(
        collection: *mut C4Collection,
        callback: C4CollectionObserverCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut C4CollectionObserver;
}
extern "C" {
    pub fn c4dbobs_getChanges(
        observer: *mut C4CollectionObserver,
        outChanges: *mut C4CollectionChange,
        maxChanges: u32,
        outExternal: *mut bool,
    ) -> u32;
}
extern "C" {
    pub fn c4dbobs_releaseChanges(changes: *mut C4CollectionChange, numChanges: u32);
}
pub type C4DocumentObserverCallback = ::std::option::Option<
    unsafe extern "C" fn(
        observer: *mut C4DocumentObserver,
        docID: C4String,
        sequence: C4SequenceNumber,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn c4docobs_create(
        database: *mut C4Database,
        docID: C4String,
        callback: C4DocumentObserverCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut C4DocumentObserver;
}
extern "C" {
    pub fn c4docobs_createWithCollection(
        collection: *mut C4Collection,
        docID: C4String,
        callback: C4DocumentObserverCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut C4DocumentObserver;
}
pub type C4QueryObserverCallback = ::std::option::Option<
    unsafe extern "C" fn(
        observer: *mut C4QueryObserver,
        query: *mut C4Query,
        context: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    pub fn c4queryobs_create(
        query: *mut C4Query,
        callback: C4QueryObserverCallback,
        context: *mut ::std::os::raw::c_void,
    ) -> *mut C4QueryObserver;
}
extern "C" {
    pub fn c4queryobs_setEnabled(obs: *mut C4QueryObserver, enabled: bool);
}
extern "C" {
    pub fn c4queryobs_getEnumerator(
        obs: *mut C4QueryObserver,
        forget: bool,
        error: *mut C4Error,
    ) -> *mut C4QueryEnumerator;
}
extern "C" {
    pub fn c4query_new2(
        database: *mut C4Database,
        language: C4QueryLanguage,
        expression: C4String,
        outErrorPos: *mut ::std::os::raw::c_int,
        error: *mut C4Error,
    ) -> *mut C4Query;
}
extern "C" {
    pub fn c4query_explain(arg1: *mut C4Query) -> C4StringResult;
}
extern "C" {
    pub fn c4query_columnCount(arg1: *mut C4Query) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn c4query_columnTitle(arg1: *mut C4Query, column: ::std::os::raw::c_uint) -> FLString;
}
extern "C" {
    pub fn c4query_setParameters(query: *mut C4Query, encodedParameters: C4String);
}
extern "C" {
    pub fn c4query_run(
        query: *mut C4Query,
        options: *const C4QueryOptions,
        encodedParameters: C4String,
        outError: *mut C4Error,
    ) -> *mut C4QueryEnumerator;
}
extern "C" {
    pub fn c4query_fullTextMatched(
        query: *mut C4Query,
        term: *const C4FullTextMatch,
        outError: *mut C4Error,
    ) -> C4StringResult;
}
extern "C" {
    pub fn c4queryenum_next(e: *mut C4QueryEnumerator, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4queryenum_getRowCount(e: *mut C4QueryEnumerator, outError: *mut C4Error) -> i64;
}
extern "C" {
    pub fn c4queryenum_seek(
        e: *mut C4QueryEnumerator,
        rowIndex: i64,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4queryenum_refresh(
        e: *mut C4QueryEnumerator,
        outError: *mut C4Error,
    ) -> *mut C4QueryEnumerator;
}
extern "C" {
    pub fn c4queryenum_close(arg1: *mut C4QueryEnumerator);
}
impl C4ReplicatorMode {
    pub const kC4Disabled: C4ReplicatorMode = C4ReplicatorMode(0);
}
impl C4ReplicatorMode {
    pub const kC4Passive: C4ReplicatorMode = C4ReplicatorMode(1);
}
impl C4ReplicatorMode {
    pub const kC4OneShot: C4ReplicatorMode = C4ReplicatorMode(2);
}
impl C4ReplicatorMode {
    pub const kC4Continuous: C4ReplicatorMode = C4ReplicatorMode(3);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4ReplicatorMode(pub i32);
impl C4ReplicatorActivityLevel {
    pub const kC4Stopped: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(0);
}
impl C4ReplicatorActivityLevel {
    pub const kC4Offline: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(1);
}
impl C4ReplicatorActivityLevel {
    pub const kC4Connecting: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(2);
}
impl C4ReplicatorActivityLevel {
    pub const kC4Idle: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(3);
}
impl C4ReplicatorActivityLevel {
    pub const kC4Busy: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(4);
}
impl C4ReplicatorActivityLevel {
    pub const kC4Stopping: C4ReplicatorActivityLevel = C4ReplicatorActivityLevel(5);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4ReplicatorActivityLevel(pub i32);
extern "C" {
    pub static kC4ReplicatorActivityLevelNames: [*const ::std::os::raw::c_char; 6usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Address {
    pub scheme: C4String,
    pub hostname: C4String,
    pub port: u16,
    pub path: C4String,
}
extern "C" {
    #[link_name = "\u{1}_ZNK9C4Address13isValidRemoteEN6fleece5sliceEP7C4Error"]
    pub fn C4Address_isValidRemote(
        this: *const C4Address,
        withDbName: fleece_slice,
        arg1: *mut C4Error,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK9C4Address5toURLEv"]
    pub fn C4Address_toURL(this: *const C4Address) -> fleece_alloc_slice;
}
extern "C" {
    #[link_name = "\u{1}_ZN9C4Address7fromURLEN6fleece5sliceEPS_PS1_"]
    pub fn C4Address_fromURL(
        url: fleece_slice,
        outAddress: *mut C4Address,
        outDBName: *mut fleece_slice,
    ) -> bool;
}
impl C4Address {
    #[inline]
    pub unsafe fn isValidRemote(&self, withDbName: fleece_slice, arg1: *mut C4Error) -> bool {
        C4Address_isValidRemote(self, withDbName, arg1)
    }
    #[inline]
    pub unsafe fn toURL(&self) -> fleece_alloc_slice {
        C4Address_toURL(self)
    }
    #[inline]
    pub unsafe fn fromURL(
        url: fleece_slice,
        outAddress: *mut C4Address,
        outDBName: *mut fleece_slice,
    ) -> bool {
        C4Address_fromURL(url, outAddress, outDBName)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4Progress {
    pub unitsCompleted: u64,
    pub unitsTotal: u64,
    pub documentCount: u64,
}
pub type C4ReplicatorStatusFlags = i32;
pub const kC4WillRetry: i32 = 1;
pub const kC4HostReachable: i32 = 2;
pub const kC4Suspended: i32 = 4;
pub type _bindgen_ty_62 = i32;
impl C4ReplicatorProgressLevel {
    pub const kC4ReplProgressOverall: C4ReplicatorProgressLevel = C4ReplicatorProgressLevel(0);
}
impl C4ReplicatorProgressLevel {
    pub const kC4ReplProgressPerDocument: C4ReplicatorProgressLevel = C4ReplicatorProgressLevel(1);
}
impl C4ReplicatorProgressLevel {
    pub const kC4ReplProgressPerAttachment: C4ReplicatorProgressLevel =
        C4ReplicatorProgressLevel(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4ReplicatorProgressLevel(pub i32);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4ReplicatorStatus {
    pub level: C4ReplicatorActivityLevel,
    pub progress: C4Progress,
    pub error: C4Error,
    pub flags: C4ReplicatorStatusFlags,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4DocumentEnded {
    pub collectionName: C4HeapString,
    pub docID: C4HeapString,
    pub revID: C4HeapString,
    pub flags: C4RevisionFlags,
    pub sequence: C4SequenceNumber,
    pub error: C4Error,
    pub errorIsTransient: bool,
}
pub type C4ReplicatorStatusChangedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut C4Replicator,
        arg2: C4ReplicatorStatus,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type C4ReplicatorDocumentsEndedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut C4Replicator,
        pushing: bool,
        numDocs: usize,
        docs: *mut *const C4DocumentEnded,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type C4ReplicatorBlobProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut C4Replicator,
        pushing: bool,
        collectionName: C4String,
        docID: C4String,
        docProperty: C4String,
        blobKey: C4BlobKey,
        bytesComplete: u64,
        bytesTotal: u64,
        error: C4Error,
        context: *mut ::std::os::raw::c_void,
    ),
>;
pub type C4ReplicatorValidationFunction = ::std::option::Option<
    unsafe extern "C" fn(
        collectionName: C4String,
        docID: C4String,
        revID: C4String,
        arg1: C4RevisionFlags,
        body: FLDict,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub type C4ReplicatorPropertyEncryptionCallback = *mut ::std::os::raw::c_void;
pub type C4ReplicatorPropertyDecryptionCallback = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4ReplicatorParameters {
    pub push: C4ReplicatorMode,
    pub pull: C4ReplicatorMode,
    pub optionsDictFleece: C4Slice,
    pub pushFilter: C4ReplicatorValidationFunction,
    pub validationFunc: C4ReplicatorValidationFunction,
    pub onStatusChanged: C4ReplicatorStatusChangedCallback,
    pub onDocumentsEnded: C4ReplicatorDocumentsEndedCallback,
    pub onBlobProgress: C4ReplicatorBlobProgressCallback,
    pub propertyEncryptor: C4ReplicatorPropertyEncryptionCallback,
    pub propertyDecryptor: C4ReplicatorPropertyDecryptionCallback,
    pub callbackContext: *mut ::std::os::raw::c_void,
    pub socketFactory: *const C4SocketFactory,
}
extern "C" {
    pub fn c4repl_isValidDatabaseName(dbName: C4String) -> bool;
}
extern "C" {
    pub fn c4repl_isValidRemote(
        remoteAddress: C4Address,
        remoteDatabaseName: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4address_fromURL(url: C4String, address: *mut C4Address, dbName: *mut C4String)
        -> bool;
}
extern "C" {
    pub fn c4address_toURL(address: C4Address) -> C4StringResult;
}
extern "C" {
    pub fn c4repl_new(
        db: *mut C4Database,
        remoteAddress: C4Address,
        remoteDatabaseName: C4String,
        params: C4ReplicatorParameters,
        outError: *mut C4Error,
    ) -> *mut C4Replicator;
}
extern "C" {
    pub fn c4repl_newWithSocket(
        db: *mut C4Database,
        openSocket: *mut C4Socket,
        params: C4ReplicatorParameters,
        outError: *mut C4Error,
    ) -> *mut C4Replicator;
}
extern "C" {
    pub fn c4repl_start(repl: *mut C4Replicator, reset: bool);
}
extern "C" {
    pub fn c4repl_stop(repl: *mut C4Replicator);
}
extern "C" {
    pub fn c4repl_retry(repl: *mut C4Replicator, outError: *mut C4Error) -> bool;
}
extern "C" {
    pub fn c4repl_setHostReachable(repl: *mut C4Replicator, reachable: bool);
}
extern "C" {
    pub fn c4repl_setSuspended(repl: *mut C4Replicator, suspended: bool);
}
extern "C" {
    pub fn c4repl_setOptions(repl: *mut C4Replicator, optionsDictFleece: C4Slice);
}
extern "C" {
    pub fn c4repl_getStatus(repl: *mut C4Replicator) -> C4ReplicatorStatus;
}
extern "C" {
    pub fn c4repl_getResponseHeaders(repl: *mut C4Replicator) -> C4Slice;
}
extern "C" {
    pub fn c4repl_getPendingDocIDs(repl: *mut C4Replicator, outErr: *mut C4Error) -> C4SliceResult;
}
extern "C" {
    pub fn c4repl_isDocumentPending(
        repl: *mut C4Replicator,
        docID: C4String,
        outErr: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4repl_getPeerTLSCertificate(
        repl: *mut C4Replicator,
        outErr: *mut C4Error,
    ) -> *mut C4Cert;
}
extern "C" {
    pub fn c4repl_setProgressLevel(
        repl: *mut C4Replicator,
        level: C4ReplicatorProgressLevel,
        outErr: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_setCookie(
        db: *mut C4Database,
        setCookieHeader: C4String,
        fromHost: C4String,
        fromPath: C4String,
        outError: *mut C4Error,
    ) -> bool;
}
extern "C" {
    pub fn c4db_getCookies(
        db: *mut C4Database,
        request: C4Address,
        error: *mut C4Error,
    ) -> C4StringResult;
}
extern "C" {
    pub fn c4db_clearCookies(db: *mut C4Database);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseNormal: C4WebSocketCloseCode = C4WebSocketCloseCode(1000);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseGoingAway: C4WebSocketCloseCode = C4WebSocketCloseCode(1001);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseProtocolError: C4WebSocketCloseCode = C4WebSocketCloseCode(1002);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseDataError: C4WebSocketCloseCode = C4WebSocketCloseCode(1003);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseNoCode: C4WebSocketCloseCode = C4WebSocketCloseCode(1005);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseAbnormal: C4WebSocketCloseCode = C4WebSocketCloseCode(1006);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseBadMessageFormat: C4WebSocketCloseCode = C4WebSocketCloseCode(1007);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketClosePolicyError: C4WebSocketCloseCode = C4WebSocketCloseCode(1008);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseMessageTooBig: C4WebSocketCloseCode = C4WebSocketCloseCode(1009);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseMissingExtension: C4WebSocketCloseCode = C4WebSocketCloseCode(1010);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseCantFulfill: C4WebSocketCloseCode = C4WebSocketCloseCode(1011);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseTLSFailure: C4WebSocketCloseCode = C4WebSocketCloseCode(1015);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseAppTransient: C4WebSocketCloseCode = C4WebSocketCloseCode(4001);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseAppPermanent: C4WebSocketCloseCode = C4WebSocketCloseCode(4002);
}
impl C4WebSocketCloseCode {
    pub const kWebSocketCloseFirstAvailable: C4WebSocketCloseCode = C4WebSocketCloseCode(5000);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4WebSocketCloseCode(pub i32);
impl C4SocketFraming {
    pub const kC4WebSocketClientFraming: C4SocketFraming = C4SocketFraming(0);
}
impl C4SocketFraming {
    pub const kC4NoFraming: C4SocketFraming = C4SocketFraming(1);
}
impl C4SocketFraming {
    pub const kC4WebSocketServerFraming: C4SocketFraming = C4SocketFraming(2);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct C4SocketFraming(pub u8);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C4SocketFactory {
    pub framing: C4SocketFraming,
    pub context: *mut ::std::os::raw::c_void,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            socket: *mut C4Socket,
            addr: *const C4Address,
            options: C4Slice,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(socket: *mut C4Socket, allocatedData: C4SliceResult),
    >,
    pub completedReceive:
        ::std::option::Option<unsafe extern "C" fn(socket: *mut C4Socket, byteCount: usize)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(socket: *mut C4Socket)>,
    pub requestClose: ::std::option::Option<
        unsafe extern "C" fn(
            socket: *mut C4Socket,
            status: ::std::os::raw::c_int,
            message: C4String,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(socket: *mut C4Socket)>,
}
extern "C" {
    pub fn c4socket_registerFactory(factory: C4SocketFactory);
}
extern "C" {
    pub fn c4Socket_setNativeHandle(arg1: *mut C4Socket, arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn c4Socket_getNativeHandle(arg1: *mut C4Socket) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn c4socket_gotHTTPResponse(
        socket: *mut C4Socket,
        httpStatus: ::std::os::raw::c_int,
        responseHeadersFleece: C4Slice,
    );
}
extern "C" {
    pub fn c4socket_opened(socket: *mut C4Socket);
}
extern "C" {
    pub fn c4socket_closed(socket: *mut C4Socket, errorIfAny: C4Error);
}
extern "C" {
    pub fn c4socket_closeRequested(
        socket: *mut C4Socket,
        status: ::std::os::raw::c_int,
        message: C4String,
    );
}
extern "C" {
    pub fn c4socket_completedWrite(socket: *mut C4Socket, byteCount: usize);
}
extern "C" {
    pub fn c4socket_received(socket: *mut C4Socket, data: C4Slice);
}
extern "C" {
    pub fn c4socket_fromNative(
        factory: C4SocketFactory,
        nativeHandle: *mut ::std::os::raw::c_void,
        address: *const C4Address,
    ) -> *mut C4Socket;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
